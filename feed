<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0">
	<channel>
		<title>LispCast</title>
		<link>http://www.lispcast.com/</link>
		<description>A blog about the simple joys of functional programming.</description>
		<language>en</language>


                <item>
                  <title>Why I start teaching Clojure with Imperative Programming</title>
                  <guid isPermalink="false">http://www.lispcast.com/imperative-intro</guid>
                  <link>http://www.lispcast.com/imperative-intro</link>
                  <pubDate>Thu 03 Mar 2016 09:58:50 PM CST</pubDate>
                  <description>
                    LispCast Introduction to Clojure starts with 30 minutes of imperative programming. We write programs for their effects, so imperative is a great place to start.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/imperative-intro"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>deftype vs defrecord</title>
                  <guid isPermalink="false">http://www.lispcast.com/deftype-vs-defrecord</guid>
                  <link>http://www.lispcast.com/deftype-vs-defrecord</link>
                  <pubDate>Thu 03 Mar 2016 06:08:29 PM CST</pubDate>
                  <description>
                    There are two commonly used ways to create new data types in Clojure, deftype and defrecord. They are similar but are intended to be used in two distinct use cases. deftype is for programming constructs and defrecord is for domain constructs.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/deftype-vs-defrecord"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>What are macros?</title>
                  <guid isPermalink="false">http://www.lispcast.com/what-are-macros</guid>
                  <link>http://www.lispcast.com/what-are-macros</link>
                  <pubDate>Thu 03 Mar 2016 05:45:27 PM CST</pubDate>
                  <description>
                    Macros are one of the most talked about features of Lisp. They are a powerful way to extend the language without modifying the compiler.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/what-are-macros"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Locks vs Concurrency Primitives</title>
                  <guid isPermalink="false">http://www.lispcast.com/locks-v-concurrency-primitives</guid>
                  <link>http://www.lispcast.com/locks-v-concurrency-primitives</link>
                  <pubDate>Mon 29 Feb 2016 05:23:08 PM CST</pubDate>
                  <description>
                    Many people have asked me why Clojure has concurrency primitives. Aren't locks good enough? A humorous metaphor is elaborated.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/locks-v-concurrency-primitives"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>All about clojure.set</title>
                  <guid isPermalink="false">http://www.lispcast.com/clojure-set</guid>
                  <link>http://www.lispcast.com/clojure-set</link>
                  <pubDate>Sun 29 Feb 2016 4:00:54 AM CST</pubDate>
                  <description>
                    clojure.set is part of the standard library that comes with Clojure. It has functions for doing set operations and relational algebra.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/clojure-set"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>What is Clojure?</title>
                  <guid isPermalink="false">http://www.lispcast.com/what-is-clojure</guid>
                  <link>http://www.lispcast.com/what-is-clojure</link>
                  <pubDate>Sat 27 Feb 2016 10:19:45 AM CST</pubDate>
                  <description>
                    Clojure is a general purpose programming language designed for the fast-approaching future.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/what-is-clojure"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>How can more layers be more efficient?</title>
                  <guid isPermalink="false">http://www.lispcast.com/more-layers</guid>
                  <link>http://www.lispcast.com/more-layers</link>
                  <pubDate>Sat 20 Feb 2016 06:19:12 PM CST</pubDate>
                  <description>
                    It's common that adding more layers of abstraction or indirection will make things slower. However, React and ClojureScript make web pages faster than doing it by hand -- essentially programming the bare web. The lesson is that if you choose your layers well, they can actually make your system faster.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/more-layers"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Reasoning About Code</title>
                  <guid isPermalink="false">http://www.lispcast.com/reasoning-about-code</guid>
                  <link>http://www.lispcast.com/reasoning-about-code</link>
                  <pubDate>Sat 20 Feb 2016 04:37:09 PM CST</pubDate>
                  <description>
                    Functional programmers often use the term &quot;reason about code&quot;. It's not very well defined generally, but I use it myself to refer to our ability to use our real-world intuition in our own code.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/reasoning-about-code"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Immutable Paper</title>
                  <guid isPermalink="false">http://www.lispcast.com/immutable-paper</guid>
                  <link>http://www.lispcast.com/immutable-paper</link>
                  <pubDate>Wed 10 Feb 2016 12:37:56 PM CST</pubDate>
                  <description>
                    Immutable data appear to contradict our observations of the real world. Things in the world are mutable, so shouldn't our data be mutable, too? It may be counterintuitive, but immutable data does a better job of modeling many of our expectations of the real world.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/immutable-paper"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Composable parts</title>
                  <guid isPermalink="false">http://www.lispcast.com/composable-parts</guid>
                  <link>http://www.lispcast.com/composable-parts</link>
                  <pubDate>Mon 08 Feb 2016 06:07:28 PM CST</pubDate>
                  <description>
                    Composition is an important idea in programming, and Functional Programming brings it to the forefront. But what does it mean to say things are composable?

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/composable-parts"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>

	</channel>
</rss>
