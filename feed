<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0">
	<channel>
		<title>LispCast</title>
		<link>http://www.lispcast.com/</link>
		<description>A blog about the simple joys of functional programming.</description>
		<language>en</language>


                <item>
                  <title>What is Clojure?</title>
                  <guid isPermalink="false">http://www.lispcast.com/what-is-clojure</guid>
                  <link>http://www.lispcast.com/what-is-clojure</link>
                  <pubDate>Sat 27 Feb 2016 10:19:45 AM CST</pubDate>
                  <description>
                    Clojure is a general purpose programming language designed for the fast-approaching future.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/what-is-clojure"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>How can more layers be more efficient?</title>
                  <guid isPermalink="false">http://www.lispcast.com/more-layers</guid>
                  <link>http://www.lispcast.com/more-layers</link>
                  <pubDate>Sat 20 Feb 2016 06:19:12 PM CST</pubDate>
                  <description>
                    It's common that adding more layers of abstraction or indirection will make things slower. However, React and ClojureScript make web pages faster than doing it by hand -- essentially programming the bare web. The lesson is that if you choose your layers well, they can actually make your system faster.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/more-layers"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Reasoning About Code</title>
                  <guid isPermalink="false">http://www.lispcast.com/reasoning-about-code</guid>
                  <link>http://www.lispcast.com/reasoning-about-code</link>
                  <pubDate>Sat 20 Feb 2016 04:37:09 PM CST</pubDate>
                  <description>
                    Functional programmers often use the term &quot;reason about code&quot;. It's not very well defined generally, but I use it myself to refer to our ability to use our real-world intuition in our own code.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/reasoning-about-code"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Immutable Paper</title>
                  <guid isPermalink="false">http://www.lispcast.com/immutable-paper</guid>
                  <link>http://www.lispcast.com/immutable-paper</link>
                  <pubDate>Wed 10 Feb 2016 12:37:56 PM CST</pubDate>
                  <description>
                    Immutable data appear to contradict our observations of the real world. Things in the world are mutable, so shouldn't our data be mutable, too? It may be counterintuitive, but immutable data does a better job of modeling many of our expectations of the real world.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/immutable-paper"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Composable parts</title>
                  <guid isPermalink="false">http://www.lispcast.com/composable-parts</guid>
                  <link>http://www.lispcast.com/composable-parts</link>
                  <pubDate>Mon 08 Feb 2016 06:07:28 PM CST</pubDate>
                  <description>
                    Composition is an important idea in programming, and Functional Programming brings it to the forefront. But what does it mean to say things are composable?

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/composable-parts"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Recommendations for Next-Level Clojure</title>
                  <guid isPermalink="false">http://www.lispcast.com/clojure-the-next-level</guid>
                  <link>http://www.lispcast.com/clojure-the-next-level</link>
                  <pubDate>Sun 24 Jan 2016 03:29:46 PM CST</pubDate>
                  <description>
                    There are many classics of functional programming that can help you take your thinking to the next level. My recommendations are for making you think in a new way.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/clojure-the-next-level"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Global Mutable State</title>
                  <guid isPermalink="false">http://www.lispcast.com/global-mutable-state</guid>
                  <link>http://www.lispcast.com/global-mutable-state</link>
                  <pubDate>Wed 06 Jan 2016 05:13:43 PM CST</pubDate>
                  <description>
                    Global mutable state is one of the biggest drivers of complexity in software systems. We tackle a definition and how to reduce our reliance on it.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/global-mutable-state"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>How to Switch from the Imperative Mindset</title>
                  <guid isPermalink="false">http://www.lispcast.com/imperative-mindset</guid>
                  <link>http://www.lispcast.com/imperative-mindset</link>
                  <pubDate>Sat 12 Dec 2015 06:04:21 AM CST</pubDate>
                  <description>
                    Functional programming, from one perspective, is just a collection of habits that affect our programming. I've identified the cues for those habits and a routine for replacing imperative code with functional code.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/imperative-mindset"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Clojure + Ruby</title>
                  <guid isPermalink="false">http://www.lispcast.com/clojure-ruby-videos</guid>
                  <link>http://www.lispcast.com/clojure-ruby-videos</link>
                  <pubDate>Wed 03 Dec 2015 10:51:00 AM CST</pubDate>
                  <description>
                    If you're a Rubyist and you've heard some buzz about Clojure, these videos and links will be just for you. Rubyists teaching Clojure, Clojurists introducing Clojure to Ruby programmers, and Rubyists pontificating on Clojure.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/clojure-ruby-videos"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>2 Features of Clojure Editors Professionals Won't Do Without</title>
                  <guid isPermalink="false">http://www.lispcast.com/clojure-editors</guid>
                  <link>http://www.lispcast.com/clojure-editors</link>
                  <pubDate>Sat 28 Nov 2015 12:00:45 AM CST</pubDate>
                  <description>
                    Professional Clojure programmers rely on certain features of their editors to help them program. When choosing an editor, it's important to pick one that has these two important features: REPL integration and structural editing.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/clojure-editors"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>

	</channel>
</rss>
