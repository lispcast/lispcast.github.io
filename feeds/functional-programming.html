<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0">
	<channel>
		<title>LispCast</title>
		<link>http://www.lispcast.com/</link>
		<description>A blog about the simple joys of functional programming.</description>
		<language>en</language>


                <item>
                  <title>Composable parts</title>
                  <guid isPermalink="false">http://www.lispcast.com/composable-parts</guid>
                  <link>http://www.lispcast.com/composable-parts</link>
                  <pubDate>Mon 08 Feb 2016 06:07:28 PM CST</pubDate>
                  <description>
                    Composition is an important idea in programming, and Functional Programming brings it to the forefront. But what does it mean to say things are composable?

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/composable-parts"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Global Mutable State</title>
                  <guid isPermalink="false">http://www.lispcast.com/global-mutable-state</guid>
                  <link>http://www.lispcast.com/global-mutable-state</link>
                  <pubDate>Wed 06 Jan 2016 05:13:43 PM CST</pubDate>
                  <description>
                    Global mutable state is one of the biggest drivers of complexity in software systems. We tackle a definition and how to reduce our reliance on it.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/global-mutable-state"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>How to Switch from the Imperative Mindset</title>
                  <guid isPermalink="false">http://www.lispcast.com/imperative-mindset</guid>
                  <link>http://www.lispcast.com/imperative-mindset</link>
                  <pubDate>Sat 12 Dec 2015 06:04:21 AM CST</pubDate>
                  <description>
                    Functional programming, from one perspective, is just a collection of habits that affect our programming. I've identified the cues for those habits and a routine for replacing imperative code with functional code.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/imperative-mindset"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>How can more layers be more efficient?</title>
                  <guid isPermalink="false">http://www.lispcast.com/more-layers</guid>
                  <link>http://www.lispcast.com/more-layers</link>
                  <pubDate>Sat 20 Feb 2016 06:19:12 PM CST</pubDate>
                  <description>
                    It's common that adding more layers of abstraction or indirection will make things slower. However, React and ClojureScript make web pages faster than doing it by hand -- essentially programming the bare web. The lesson is that if you choose your layers well, they can actually make your system faster.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/more-layers"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Object-Oriented Dispatch is the Dual of Functional Dispatch</title>
                  <guid isPermalink="false">http://www.lispcast.com/object-function-duals-dispatch</guid>
                  <link>http://www.lispcast.com/object-function-duals-dispatch</link>
                  <pubDate>Wed 11 Mar 2015 02:56:53 PM CDT</pubDate>
                  <description>
                    Object-oriented dispatch is contrasted with functional dispatch, but they are shown to be two one-dimensional projections of the same two-dimensional data. Clojure does not provide the two-dimensional representation, but does interesting things to transcend the one-dimensional views.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/object-function-duals-dispatch"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Object-Oriented Programming is the Dual of Functional Programming</title>
                  <guid isPermalink="false">http://www.lispcast.com/object-oriented-vs-functional-duals</guid>
                  <link>http://www.lispcast.com/object-oriented-vs-functional-duals</link>
                  <pubDate>Sun 08 Feb 2015 11:22:31 AM CST</pubDate>
                  <description>
                    Object-Oriented Programming is often shown in contrast to Functional Programming. But they are so exactly opposite that they are duals, and so equivalent in important ways. Which one to use should be left up to the programmer, as is done in Clojure and Javascript.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/object-oriented-vs-functional-duals"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>The Paper Metaphor</title>
                  <guid isPermalink="false">http://www.lispcast.com/paper-metaphor</guid>
                  <link>http://www.lispcast.com/paper-metaphor</link>
                  <pubDate>Fri 27 Feb 2015 12:57:38 PM CST</pubDate>
                  <description>
                    Functional programs follow a simple rule: never write on the same paper twice. Imperative programs are free to define their own rules. Both have interesting consequences.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/paper-metaphor"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Reasoning About Code</title>
                  <guid isPermalink="false">http://www.lispcast.com/reasoning-about-code</guid>
                  <link>http://www.lispcast.com/reasoning-about-code</link>
                  <pubDate>Sat 20 Feb 2016 04:37:09 PM CST</pubDate>
                  <description>
                    Functional programmers often use the term &quot;reason about code&quot;. It's not very well defined generally, but I use it myself to refer to our ability to use our real-world intuition in our own code.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/reasoning-about-code"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>The Content of Your Code</title>
                  <guid isPermalink="false">http://www.lispcast.com/the-content-of-your-code</guid>
                  <link>http://www.lispcast.com/the-content-of-your-code</link>
                  <pubDate>Mon 06 Oct 2014 02:25:46 PM CDT</pubDate>
                  <description>
                    Code style is important, but way less important than content. Yet everyone talks about style because it's easier. Let's talk about content.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/the-content-of-your-code"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>But the World is Mutable</title>
                  <guid isPermalink="false">http://www.lispcast.com/the-world-is-mutable</guid>
                  <link>http://www.lispcast.com/the-world-is-mutable</link>
                  <pubDate>Mon 11 May 2015 11:46:58 PM CDT</pubDate>
                  <description>
                    The world may be mutable, but people have been using the notion of immutability to build reliable systems for a long time.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/the-world-is-mutable"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>What is Functional Programming?</title>
                  <guid isPermalink="false">http://www.lispcast.com/what-is-functional-programming</guid>
                  <link>http://www.lispcast.com/what-is-functional-programming</link>
                  <pubDate>Tue 01 Jul 2014 10:47:20 AM CDT</pubDate>
                  <description>
                    I prefer to define Functional Programming as making a distinction between pure and impure code. With this definition, you can program functionally in any language. What differentiates the functional languages is how much help they give you to make the distinction.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/what-is-functional-programming"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Deconstructing Functional Programming</title>
                  <guid isPermalink="false">http://www.lispcast.com/deconstructing-functional-programming</guid>
                  <link>http://www.infoq.com/presentations/functional-pros-cons</link>
                  <pubDate>Sun 22 Dec 2013 04:33:32 PM CST</pubDate>
                  <description>
                    
&lt;blockquote&gt;
&lt;p&gt;Because if you think about it, the stack itself is just an optimization. Right? There are these frames which contain information about each invocation. Each stack frame. Each activation record. And that's what they are--they're activation records. They're sort of objects. If you really have objects on the brain, like I do, then you realize that they're all just objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;And they should be treated uniformly. You can even build a language that works this way--as I have. If that's the case, this is really a garbage collection problem. Right? Your stack traces might go away if you don't need them. You do need them when it's not a tail call because you need to go back there and use that information. But if it's a tail call, you don't need them, you don't need a tail call back to that frame. You need a pointer back to the last frame that wasn't a tail call. And they might get collected.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Which doesn't mean you actually have to implement it that way. Erlang sort of does. And there are many implementations that do that. They are not noted for their speed. If you can have real stacks, what happens when you run out of space? If you don't run out of space, it didn't really matter if you optimized the tail calls or not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;When you run out of space, you should GC the damned stack. You shouldn't just throw up your hands and say you're dead. And for all the normal programs that people write where it didn't matter, they won't care. And for your tail recursive programs, well, they might be a bit slower, but they will work. And then it's a matter of flags to the garbage collector if in production you don't want to debug it if you're sure it's all going to be fine--then go ahead and tell it to don't bother and just slam it and overwrite those frames directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Why is this so hard for implementers to do? Optimization is an optimization and should be optional.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It's a cool algorithm, but there's nothing nice that I'm prepared to say about Hindley-Milner.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;He nails a lot of things I didn't like about Haskell.&lt;/p&gt;
&lt;p&gt;All in all, this talk gets a lot of things right.&lt;/p&gt;
&lt;h3 id=&quot;you-might-also-like&quot;&gt;You might also like&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.lispcast.com/composable-parts&quot;&gt;Composable parts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.lispcast.com/global-mutable-state&quot;&gt;Global Mutable State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.lispcast.com/imperative-mindset&quot;&gt;How to Switch from the Imperative Mindset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.lispcast.com/more-layers&quot;&gt;How can more layers be more efficient?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/deconstructing-functional-programming"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>

	</channel>
</rss>
