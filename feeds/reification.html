<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0">
	<channel>
		<title>LispCast</title>
		<link>http://www.lispcast.com/</link>
		<description>A blog about the simple joys of functional programming.</description>
		<language>en</language>


                <item>
                  <title>Infinite Application</title>
                  <guid isPermalink="false">http://www.lispcast.com/infinite-application</guid>
                  <link>http://www.lispcast.com/infinite-application</link>
                  <pubDate>Sun 17 May 2015 10:26:44 PM CDT</pubDate>
                  <description>
                    Function application is a key concept in lambda calculus. While it is commonly expressed using parentheses in Clojure, it is also reified into a function which itself can be applied to another function.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/infinite-application"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>


                <item>
                  <title>Reification</title>
                  <guid isPermalink="false">http://www.lispcast.com/reification</guid>
                  <link>http://www.lispcast.com/reification</link>
                  <pubDate>Tue 05 Aug 2014 10:39:50 PM CDT</pubDate>
                  <description>
                    Reification means making an abstraction into a concrete value that can be manipulated at runtime. Reification is the core of what makes a language dynamic. Three types of reification in Clojure are discussed.

                    &lt;p&gt;&lt;center&gt;&lt;a href="http://www.lispcast.com/reification"&gt;Read full post&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

                  </description>
                </item>

	</channel>
</rss>
