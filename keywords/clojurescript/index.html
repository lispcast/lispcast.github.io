<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
    <link href='http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

    <title>Keyword: clojurescript | LispCast</title>
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@ericnormand">
    <meta name="twitter:creator" content="@ericnormand">
    <meta name="twitter:description" content="A blog about the simple joys of functional programming.">
    <meta name="twitter:title" content="Keyword: clojurescript">

    <meta property="og:title" content="Keyword: clojurescript">
    <meta property="og:description" content="A blog about the simple joys of functional programming.">

    <meta name="description" content="A blog about the simple joys of functional programming.">

    <meta name="author" content="Eric Normand">

    <meta name="viewport" content="width=device-width,initial-scale=1">

    <!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/styles.css" type="text/css">

    <link rel="alternate" type="application/rss+xml"
    title="LispCast" href="/feed" />

    <!-- start Mixpanel --><script type="text/javascript">(function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
      for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);
                  mixpanel.init("ffad2bd88d2cb690edbbba6cf30b2958");</script><!-- end Mixpanel -->
                  </head>

  <body>
    <header class="banner">
      <h1 class="banner-logo">
        <a href="/">
          <img class="banner-logo-img"
               src="/img/Logo@2x.png"
               alt="LispCast" />
        </a>
      </h1>

      <div class="meta-data">
        <img class="bio-img"
             src="/img/eric_bio.jpg" />
        <a class="twitter-link"
           href="http://twitter.com/ericnormand">
          <i class="fa fa-twitter"></i>
        </a>
        <a class="github-link"
           href="https://github.com/ericnormand">
          <i class="fa fa-github"></i>
        </a>
        <a class="mail-link"
           href="mailto:eric@lispcast.com">
          <i class="fa fa-envelope"></i>
        </a>
        <a class="rss-link"
           href="/feed">
          <i class="fa fa-rss-square"></i>
        </a>
        <a class="rss-link"
           href="/archive.html">
          <i class="fa fa-list"></i>
        </a>
      </div>

    </header>

    <div class="main-container">


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/core-async-browser-motivation">
            core.async in Browsers
          </a>
        </h2>

        <div class="timestamp">
          July 29, 2014
        </div>

        
<p>Summary: <em>Javascript's concurrency model forces code to give up control of when a callback will be called. <code>core.async</code> gives you back that control and hence lets you code in a more natural style.</em></p>
<p>Well, there comes a time in every programmer's life when they take a look at the <a href="http://www.thoughtworks.com/radar/#/languages-and-frameworks/core-async">ThoughtWorks Technology Radar</a> and they realize that <code>core.async</code> is in the Trial circle, meaning <strong>you should see if you might want to use it</strong>.</p>
<p>And if you're there, right there in that phase of your programming trajectory, eyeballing <code>core.async</code> for your next (or current) project, Welcome. This post is for you. Here it goes.</p>
<p><strong>Why <code>core.async</code>?</strong> Well, the short answer is that it makes concurrency much, much, much, very much easier. I mean, let's face it: <strong>concurrency is so hard by itself</strong>, it has plenty of muches to spare. Now, I haven't used <code>core.async</code> a lot on the JVM. I wrote some, but it wasn't really the right thing for it. I plan on writing more later, I just haven't had the right project for it.</p>
<p>But I have used it a lot in ClojureScript in browsers. <sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> And it is nice. It lets you do things that you could write yourself, given enough time. But you're more likely to solve the 16-ring Tower of Hanoi before you get all the kinks out. It's much better to <strong>let a machine do the hard work</strong>. That's what the 20th Century was all about: machines instead of muscle. And the 21st Century will be about computers instead of brains. Best get ahead of the curve.</p>
<p>I say you should let the machine do the work, but maybe that's too vague. Let's look at a concrete example. First, <strong>how do you do an ajax request then do something with the value?</strong> Easy:</p>
<pre><code>(ajax &quot;http://example.com/json-api&quot;
      #(js/console.log %))</code></pre>
<p><sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p>We're in Javascript, so we have to pass a callback which will get the result. That was easy. A little harder is <strong>making two API calls and doing something with both results</strong>.</p>
<pre><code>(ajax &quot;http://example.com/random-number&quot;
      (fn [r1]
        (ajax &quot;http://example.com/non-random-number&quot;
              (fn [r2]
                (js/console.log (/ (:n r1) (:n r2)))))))</code></pre>
<p>Alright, that wasn't too bad. <strong>A little indentation never hurt anyone.</strong> But, wait a second! <strong>We don't do the second request until the first request is already done.</strong> I've got a browser the size of a minivan and a 20 Megabit internet connection, and I'm doing one request at a time? That sucks!</p>
<p>We could start them both at the same time. But what order will they come back in? Welcome to the world of concurrency!!!! Things happening (maybe) at the same time, or at least <strong>you don't know what order they will happen in!</strong></p>
<p>Well, let's try something. What if <strong>the first one to finish wrote its result down, then the second one to finish would know that it was second</strong> and it could do the final calculation? What would that look like?</p>
<pre><code>(def r1 (atom nil))
(def r2 (atom nil))

(defn final-calculation []
  (js/console.log (/ @r1 @r2)))

(defn try-final-calculation []
  (when (and @r1 @r2)
    (final-calculation)))

(ajax &quot;http://example.com/random-number&quot;
  #(do
    (reset! r1 %)
    (try-final-calculation)))

(ajax &quot;http://example.com/non-random-number&quot;
  #(do
    (reset! r2 %)
    (try-final-calculation)))</code></pre>
<p>Ok, well, that should work. What happens if you have to do 3 AJAX requests? Not so bad, either. What about 17? Oh, man, that sucks. We could do something like make a super-promise, where <strong>you can promise many values and only call a function at the end</strong> when they're all there. Yes, you can do that. It really wouldn't be hard, even.</p>
<pre><code>(defn super-promise
  &quot;Create a promise for many values. Use `deliver`
  to add values.

  keys: all of these keys must be present before calling f
  f: the function to call. Will be passed a map.&quot;
  [keys f]
  (let [r (atom {})]
    (add-watch r :promise
               (fn [_ _ _ s]
                 (when (every? #(contains? s %) keys)
                   (f s))))
    r))

(defn deliver [promise key value]
  (swap! promise assoc key value))

(def rs (super-promise [:r1 :r2]
                       (fn [{:keys [r1 r2]}]
                         (js/console.log (/ (:n r1) (:n r2))))))

(ajax &quot;http://example.com/random-number&quot;
  #(deliver rs :r1 %))

(ajax &quot;http://example.com/non-random-number&quot;
  #(deliver rs :r2 %))</code></pre>
<p>Fhew! That's done. It works. It scales to many simultaneous AJAX calls. It's generic. Well, generic for <em>this</em> particular pattern. If we have a different pattern, we'd have to <strong>come up with a different solution</strong>.</p>
<p>We're looking through a small porthole into <em>callback hell</em>. The identifying characteristic of callback hell is that you give over control from your code, which was all nice and procedural and easy to follow, you give the control over to whatever demon is going to call that callback. You sell your virtual soul for a bit of asynchrony. But you can't cheat the Devil. When all is said and done, all of your work gets done but <strong>you need some savior angel to help you coordinate all of the pieces back together again</strong>. In this case, it's the super-promise, which works in the first circle of hell, but even Dante can't help you if you go further.<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup></p>
<p>Now that we've got a decent solution <em>to this particular problem</em> established pre-<code>core.async</code>, let's look at what it would be using <code>core.async</code>. We'll assume that our <code>ajax-channel</code> function returns a <code>core.async</code> channel.</p>
<pre><code>(let [r1-channel (ajax-channel &quot;http://example.com/random-number&quot;)
      r2-channel (ajax-channel &quot;http://example.com/non-random-number&quot;)]
  (go
    (js/console.log (/ (:n (&lt;! r1-channel)) (:n (&lt;! r2-channel))))))</code></pre>
<p>Let me just get it out of the way and never mention it again: <em>it's shorter</em>. It's shorter even than the naive solution using two atoms. And it's shorter than the <code>super-promise</code> solution even if you don't include the <code>super-promise</code> code. I'm done talking about the size, because <strong>it's only a little important</strong>.</p>
<p>Now that that's out there, on to the more significant stuff. First and foremost is that <strong>you never lose control</strong>. The code even reads procedurally. Start two ajax requests and remember the channels. Start a <code>go</code> block (which means run the code asynchronously) and log the result of dividing the first result by the second result.</p>
<p>Does it scale? You betcha! Imagine we need to make 192 imaginary AJAX calls before the Devil takes his due. The <em>only</em> way to do that is to <strong>do them all as fast as the browser fairies let you</strong>.</p>
<pre><code>(let [numbers (range 192)
      urls (map #(str &quot;http://example.com/choir?angelid=&quot; %) numbers)
      channels (map ajax-channel urls)]
  (go
    (doseq [c channels]
      (js/console.log &quot;Got: &quot; (&lt;! c)))))</code></pre>
<p>The AJAX requests come back as fast as they can (meaning arbitrary order), and the results are logged in their original (numeric) order. <strong>You could do them in any order you want. That's because you're not giving up control.</strong></p>
<p>How does this work? How can you have asynchrony and not give up control?</p>
<p>I alluded to it before: <strong>you're making the machine do the work</strong>. That <code>go</code> block up there is actually a powerful macro that transforms your procedural code into a mess of callbacks (like in our <code>super-promise</code> example) that you would never want to write yourself. I mean, maybe you want to, but maybe you're nuts. <strong>And you'll get it wrong.</strong></p>
<p>The transformation in the <code>go</code> block is pretty easy, as things go. It's mechanical. It's easy like lifting a car with your hands. Put enough leverage (by using a jack) and you can do it. It converts an easy motion (pushing down on the lever or turning the screw) into a powerful force. The <code>go</code> macro converts your easy code into a bunch of callbacks and coordinates them with a powerful state machine which will <strong>angelically reassemble them without ever losing control</strong>.</p>
<p>It's all good-ol' callbacks and mutable state underground. But above ground, you've got code that's easy to reason about. No Devil's bargain. You've got an angel negotiating for you. That's the key thing! Channels are amazingly easy to reason about because <strong>each channel is so simple</strong>. But that's a story for another day!</p>
<p>I should just mention that, yes, <code>core.async</code> is about procedural programming. Channels are mutable state. <code>core.async</code> is made for the small <strong>part of your code that is procedural and side-effecting</strong>. Every program has got such a part. If you're doing concurrent things (and in Javascript, you always are), <code>core.async</code> might be able to help provide a first-class mechanism for communication and coordination.</p>
<p>That's what you might call the &quot;core&quot; of <code>core.async</code> in ClojureScript. <strong>It's about regaining control of your asynchronous calls and not smearing your logic across your code in little bits contained in callbacks.</strong> You keep your code's semantic integrity and you keep your sanity.</p>
<p>If <strong>staying out of callback hell is to your liking</strong>, you just might like the divine help of a LispCast video course dedicated to teaching <code>core.async</code> in a gentle, graceful way. Presented in a unique visual format and at just the right pace, LispCast <a href="http://www.purelyfunctional.tv/core-async#channel-preview">Clojure core.async</a> will guide you to a deep understanding of the fundamentals of <code>core.async</code> so you can clean up your code, get more concurrency, and get back control.</p>
<div class="subscribe-form-wrapper">
  <form class="subscribe-form"
        action="https://lispcast.us4.list-manage.com/subscribe/post?u=a33b5228d1b5bf2e0c68a83f4&amp;id=d0f96276d9"
        method="POST"
        name="mc-embedded-subscribe-form"
        novalidate="true">
      <h3 class="subscribe-form-title">
        
Get a Free core.async Reference Sheet
</h3>
    
<img class="subscribe-form-image"
         src="http://www.lispcast.com/img/core_async_reference_thumb.png">
<div class="subscribe-form-text">
      <p class="subscribe-form-description">
        
Subscribe below to receive a free copy of the core.async reference sheet. If you are interested in core.async, this reference sheet contains lots of the important functions in a handy format. You'll also get a few emails introducing you to core.async.
</p>
      
<input id="mce-EMAIL.email-field"
             type="email"
             value=""
             placeholder="Email"
             name="EMAIL"> <input type="hidden"
             name="group[18565][8]"
             value="1">
<div style="position: absolute; left: -5000px;">
        
<input type="text"
               name="b_a33b5228d1b5bf2e0c68a83f4_d0f96276d9">
</div>
      
<input class="subscribe-button"
             type="submit"
             value="Get it"
             name="subscribe">
<div class="field-text-text2">
        
No spam. Ever.
</div>
    </div>
  </form>
</div>




<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/core-async-code-style">core.async Code Style</a></li>
<li><a href="http://www.lispcast.com/core-async-conveyor-belts-true-history">Conveyor Belts: Nature's core.async Channels</a></li>
<li><a href="http://www.lispcast.com/elm-frp-clojure-core-async">Elm FRP in Clojure core.async</a></li>
<li><a href="http://www.lispcast.com/is-core-async-against-clojure-philosophy">Is core.async Against the Clojure Philosophy?</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Don't say &quot;the browser&quot; because there are many and they are different.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Let's imagine these functions exist and work as expected.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>And thank Clojure for the <code>atom</code>, which is like a cross or holy water when you find yourself <em>down there</em>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/mastering-client-side-routing-with-secretary-and-goog-history">
            Mastering ClojureScript Routing with Secretary and goog.History
          </a>
        </h2>

        <div class="timestamp">
          June 24, 2015
        </div>

        
<p>Summary: <em>The Google Closure Library provides a nice interface to the HTML5 History API. Coupling it with Secretary is very easy. But not all browsers support HTML5 History. In this post I'll talk about one way to make sure you have client-side routing in all browsers.</em></p>
<h3 id="background">Background</h3>
<p><em>About a year ago I was working for a company of three people. Two coders and one business person. I was developing a consumer product and the other programmer was building a related B2B product. We were as agile as could be: no planning meetings, no prioritized list of features, just a shared vision. I was working in Clojure and ClojureScript and getting paid to do it.</em></p>
<p><em>That job eventually disappeared. But the amount of code I produced and the dark corners of features I explored still surprises me. I discovered (uncovered?) a lot of gems of ClojureScript in that time. This post is about one of them.</em></p>
<p><strong>Update</strong>: Andre Rauh pointed out that I was using a require when I should use an import for <code>goog.history.EventType</code>. I fixed it in the code. Thanks!</p>
<h3 id="browser-history">Browser History</h3>
<p>In a project I did about a year ago, we wanted the speed of a single page application but we wanted the back button to work and we wanted the URL to reflect where the reader was in the app. We turned to the <strong>HTML5 History API</strong>.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/History">HTML5 History API</a> is an API for manipulating the browser's history without making a request to the server and loading a new page. The idea is that <strong>your Javascript application can keep all of its state in memory, but still change the URLs and keep the back button working</strong>. You have to code it up yourself, but it gives you fine-grained control over what exactly the back button does.</p>
<p>Luckily (and not surprisingly), the Google Closure Library has a nice way to access the History API. It's in a class called <a href="https://closure-library.googlecode.com/git-history/docs/class_goog_history_Html5History.html"><code>goog.history.Html5History</code></a>. That gives you <strong>events about when the URL changes</strong>. We used that along with <a href="https://github.com/gf3/secretary">Secretary</a> to parse, interpret, and dispatch on the URL.</p>
<h3 id="the-code">The code</h3>
<p>First, we set up our <code>ns</code> declaration.</p>
<pre><code>(ns history.core
  (:require
   [secretary.core :as secretary :refer-macros [defroute]]
   [goog.events])
  (:import
   [goog.history Html5History EventType]))</code></pre>
<p>We need a function that will get the current path fragment to switch on. We'll just use the path and the query string.</p>
<pre><code>(defn get-token []
  (str js/window.location.pathname js/window.location.search))</code></pre>
<p>Now we define how to instatiate the history object.</p>
<pre><code>(defn make-history []
  (doto (Html5History.)
    (.setPathPrefix (str js/window.location.protocol
                         &quot;//&quot;
                         js/window.location.host))
    (.setUseFragment false)))</code></pre>
<p>Let's make a couple of simple routes. I won't go into how to make routes with Secretary in this post.</p>
<pre><code>(defroute home-page &quot;/&quot; []
  (js/console.log &quot;Homepage!&quot;))

(defroute default-route &quot;*&quot; []
  (js/console.log (str &quot;unknown route: &quot; (get-token))))</code></pre>
<p>Now a handler for what to do when the URL changes.</p>
<pre><code>(defn handle-url-change [e]
  ;; log the event object to console for inspection
  (js/console.log e)
  ;; and let&#39;s see the token
  (js/console.log (str &quot;Navigating: &quot; (get-token)))
  ;; we are checking if this event is due to user action,
  ;; such as click a link, a back button, etc.
  ;; as opposed to programmatically setting the URL with the API
  (when-not (.-isNavigation e)
    ;; in this case, we&#39;re setting it
    (js/console.log &quot;Token set programmatically&quot;)
    ;; let&#39;s scroll to the top to simulate a navigation
    (js/window.scrollTo 0 0))
  ;; dispatch on the token
  (secretary/dispatch! (get-token)))</code></pre>
<p>Now we set up our global history object. We use <code>defonce</code> so we can <strong>hot reload the code</strong>.</p>
<pre><code>(defonce history (doto (make-history)
                   (goog.events/listen EventType.NAVIGATE
                                       ;; wrap in a fn to allow live reloading
                                       #(handle-url-change %))
                   (.setEnabled true)))</code></pre>
<p>And we will want a function to programmatically change the URL (and add to the history).</p>
<pre><code>(defn nav! [token]
  (.setToken history token))</code></pre>
<h3 id="om-example-link">Om example link</h3>
<p>Incidentally, my links look like this in Om:</p>
<pre><code>(dom/a
  #js {:href &quot;/some/page&quot;
       :onClick #(do
                   (.preventDefault %)
                   (nav! &quot;/some/page&quot;))}
  &quot;some page&quot;)</code></pre>
<p>That is, I try to follow the principle of graceful fallback. If Javascript fails for some reason, the <code>href</code> is still valid. It will make a request to the server and fetch the page. But if Javascript is working, we override it.</p>
<p>On the server side, I make sure that the same routes exist and that they return valid pages that include this script. When the page loads, the <code>EventType.NAVIGATE</code> event will fire, and so Secretary will route it. This usually means a repaint, but it's very quick and acceptable.</p>
<p>Add the requires:</p>
<pre><code>   [om.core :as om]
   [om.dom :as dom]</code></pre>
<p>And the Om code to render and get it started:</p>
<pre><code>(defonce state (atom {}))

(defn cmp-link [cursor owner]
  (reify
    om/IRender
    (render [_]
      (dom/a
       #js {:href &quot;/some/link&quot;
            :onClick #(do
                        (.preventDefault %)
                        (nav! &quot;/some/link&quot;))}
       &quot;some link&quot;))))

(om/root cmp-link state
         {:target (. js/document (getElementById &quot;app&quot;))})</code></pre>
<p>When you click the link, you should see a message in the console saying it's navigating to <code>/some/link</code>.</p>
<h3 id="a-hitch">A hitch</h3>
<p>I was using this for a while when I got a message about it not working for someone. After a little investigation, it turned out they were using an older version of IE. :( <strong>IE &lt;= 9 does not support HTML5 History.</strong> In fact, according to caniuse.com, <a href="http://caniuse.com/#feat=history">only 88.2% of users have a browser with HTML5 support</a>. That means that 12 out of every 100 visitors can't use what we just wrote.</p>
<p>What a lot of people would do at this point is just to use the hash-based history wrangling that <a href="http://caniuse.com/#search=hash">93% of the internet supports</a>. But I wanted to do better without punishing people who upgrade their browsers.</p>
<p>Here's what I did: the server still serves content at URLs as normal. The routes on the client stay the same. <em>But</em> I used feature detection to <strong>determine if the browser supports HTML5 History</strong>. If it does support it, it runs the code above. If it doesn't, it uses the hash API. Lucky for me, Google Closure has a class called <a href="https://closure-library.googlecode.com/git-history/docs/class_goog_History.html"><code>goog.History</code></a> that is interface-compatible with <code>goog.history.Html5History</code>. So 90% of the work was done.</p>
<p>First, we need to add this import:</p>
<pre><code>  [goog History]</code></pre>
<p><code>goog.history.Html5History</code> required a tiny little patch to work.</p>
<pre><code>;; Replace this method:
;;  https://closure-library.googlecode.com/git-history/docs/local_closure_goog_history_html5history.js.source.html#line237
(aset js/goog.history.Html5History.prototype &quot;getUrl_&quot;
      (fn [token]
        (this-as this
          (if (.-useFragment_ this)
            (str &quot;#&quot; token)
            (str (.-pathPrefix_ this) token)))))</code></pre>
<p>I was very reluctant to do that, but it was the only solution I found to making it work consistently with the query string. Unfortunately, it was done a year ago and I don't remember the exact reason.</p>
<p>Now we need to modify <code>get-token</code> so it works in both cases. In the case HTML5 History is not supported, the token is everything after the <code>#</code> if we're on <code>/</code>.</p>
<pre><code>(defn get-token []
  (if (Html5History.isSupported)
    (str js/window.location.pathname js/window.location.search)
    (if (= js/window.location.pathname &quot;/&quot;)
      (.substring js/window.location.hash 1)
      (str js/window.location.pathname js/window.location.search))))</code></pre>
<p><code>make-history</code> is different, too. If we don't support HTML5 History, we check if we're on <code>/</code>. If not, we redirect to <code>/</code> with the token. If we are, we construct an instance of <code>goog.History</code>.</p>
<pre><code>(defn make-history []
  (if (Html5History.isSupported)
    (doto (Html5History.)
      (.setPathPrefix (str js/window.location.protocol
                           &quot;//&quot;
                           js/window.location.host))
      (.setUseFragment false))
    (if (not= &quot;/&quot; js/window.location.pathname)
      (aset js/window &quot;location&quot; (str &quot;/#&quot; (get-token)))
      (History.))))</code></pre>
<p>Everything else is the same! You can even test out what happens without the HTML5 History API by replacing the <code>(Html5History.isSupported)</code> with <code>false</code> in both places in the code above. You'll see it start to use the <code>#</code> fragment when you click the link!</p>
<h3 id="conclusions">Conclusions</h3>
<p>I figured out all of this stuff incrementally by experimentation. I wanted to share this with you because I think it's valuable. The biggest lesson to take away is that <strong>the Google Closure Library is <em>very</em> complete and well-built</strong>. We should lean on it as much as we can from ClojureScript.</p>
<p>If you're interested in learning some ClojureScript, Om, and how to make Single Page Applications, I have to recommend my LispCast Single Page Applications with ClojureScript and Om course. It's interactive with lots of animations, exercises, screencasts, and code. It's designed to get you <strong>up and running with a smooth dev process all the way through deploying code to production</strong>. It won't teach you <em>everything</em> about ClojureScript and Om, but it will get you over lots of the major hurdles we all encounter.</p>
<div class="subscribe-form-wrapper">
  <form class="subscribe-form"
        action="https://lispcast.us4.list-manage.com/subscribe/post?u=a33b5228d1b5bf2e0c68a83f4&amp;id=d0f96276d9"
        method="POST"
        name="mc-embedded-subscribe-form"
        novalidate="true">
      <h3 class="subscribe-form-title">
        
Get free Clojure stuff and news on ClojureScript courses
</h3>
    
<img class="subscribe-form-image"
         src="http://www.lispcast.com/img/spaom-cover.jpg">
<div class="subscribe-form-text">
      <p class="subscribe-form-description">
        
The LispCast Single Page Applications with ClojureScript and Om course is in development <em>right now</em>! Sign up here to get news as it's being created and learn when it will launch. Also, you'll get to download all of the free stuff for learning and using Clojure.
</p>
      
<input id="mce-EMAIL.email-field"
             type="email"
             value=""
             placeholder="Email"
             name="EMAIL"> <input type="hidden"
             name="group[18565][64]"
             value="1">
<div style="position: absolute; left: -5000px;">
        
<input type="text"
               name="b_a33b5228d1b5bf2e0c68a83f4_d0f96276d9">
</div>
      
<input class="subscribe-button"
             type="submit"
             value="Get it"
             name="subscribe">
<div class="field-text-text2">
        
No spam. Ever.
</div>
    </div>
  </form>
</div>




<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/core-async-browser-motivation">core.async in Browsers</a></li>
<li><a href="http://www.lispcast.com/react-another-level-of-indirection">React: Another Level of Indirection</a></li>
<li><a href="http://www.lispcast.com/pre-conj-anna-pawlicka">Pre-conj Prep: Anna Pawlicka</a></li>
<li><a href="http://www.lispcast.com/pre-conj-interview-anna-pawlicka">Pre-Conj Interview: Anna Pawlicka</a></li>
</ul>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/react-another-level-of-indirection">
            React: Another Level of Indirection
          </a>
        </h2>

        <div class="timestamp">
          December 31, 2013
        </div>

        
<blockquote>
<p>Any problem in computer science can be solved with another level of indirection. -- David Wheeler</p>
</blockquote>
<p>The <a href="http://facebook.github.io/react/">React</a> library from Facebook makes DOM programming functional by using a Virtual DOM. The Virtual DOM is an <em>indirection mechanism</em> that solves the difficult problem of DOM programming: <strong>how to deal with incremental changes to a stateful tree structure</strong>. By abstracting away the statefulness, the Virtual DOM turns the real DOM into an immediate mode GUI, which is perfect for functional programming. Further, the Virtual DOM provides <strong>the last piece of the Web Frontend Puzzle for ClojureScript</strong>.</p>
<p>David Nolen has written up a <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">short explanation</a> of how the Virtual DOM works, as well as some amazing performance benchmarking of React in a ClojureScript context. His work is important, so you should read it. I'd like to focus a bit more on the expressivity and why <strong>I would use React even if it were not so fast</strong>.</p>
<p>One can view MVC frameworks as an attempt to impose some structure on the code that has to interface with the DOM. The bargain they propose is this: <strong>wrap the DOM in View objects</strong>, so that subtrees of DOM nodes are managed by a View object. <strong>Wrap your state in Model objects</strong>, which will notify the View objects of changes. You thereby keep a <em>layer of indirection between Models and Views</em>, which inherently need different structure and need to change independently.</p>
<p>The layer of indirection (usually an event or observer system) solves a <em>coupling problem</em>. It decouples your state from the DOM, while <strong>leaving you to deal with all of the difficulties of the DOM</strong>. You are essentially making a new type of DOM that is better suited to your GUI domain than plain HTML, but is still a PITA. It is little more than a coat of paint. <em>The DOM is still stateful.</em></p>
<p>React takes a different approach. It provides a level of indirection which solves the actual problem with the DOM--statefulness. The DOM has become a smart canvas. <strong>Paint the whole picture again, but only the different parts get wet.</strong></p>
<p>Instead of wrapping the DOM in View objects, you create a Virtual DOM (completely managed by React) which mirrors the real DOM. When the model changes, you generate a new Virtual DOM. The differences are calculated and converted into batch operations to the real DOM. In essence, <strong>React is a function which takes two DOMs and generates a list of DOM operations</strong>, <em>i.e.</em>, <strong>it's referentially transparent</strong>.</p>
<p>It's easy to imagine how this changes the game. <strong>You no longer need an initializer to set up the DOM and observers to modify it.</strong> The first Virtual DOM rendering is like the second one, in fact like any other! Your &quot;View&quot;, if you want to call it that, is simply a function from state to Virtual DOM nodes. <strong>If the state and DOM nodes are immutable, all the better.</strong> There's less work to know if it has changed.</p>
<p>This also means that your Views can be composed functionally. Define a component (as a function) and your subcomponents, and build them up functionally. All of the functional abstraction and refactoring that you're used to is available. If you're doing it right, <strong>your code should get shorter, easier to read, and more fun to maintain</strong>.</p>
<p>My (short) experience rewriting a program to use React converted me. It was the only library I have used that actually made DOM programming fun and functional--and dare I say my code now works!</p>
<p>Which gets me to my last point, which is that React is the final puzzle piece for ClojureScript web frontend development.</p>
<ul>
<li>Problem: <strong>Global state management</strong></li>
<li><p>Solution: Atoms and persistent data structures</p></li>
<li>Problem: <strong>Client-server communication</strong></li>
<li><p>Solution: EDN (also solved pretty well by JSON)</p></li>
<li>Problem: <strong>Callback hell</strong></li>
<li><p>Solution: core.async</p></li>
<li>Problem: <strong>Stateful DOM</strong></li>
<li><p>Solution: React</p></li>
</ul>
<p>Any other problems left? I can't think of any. That's something to <a href="http://www.twitter.com/ericnormand"><em>discuss on Twitter</em></a>.</p>
<p>I suggest you try React. <a href="https://github.com/swannodette/om"><em>Om</em></a> by David Nolen is the most mature React ClojureScript library I know of. It does a bit more than I've described here (Om manages your state tree for you, among other things) and is evolving quickly. I have some code that generates React Virtual DOM using <code>hiccup</code> style with macros (so the work is done at compile time), but other than that, contains only half-baked implementations of what's in Om. If you're interested in the <code>hiccup</code> macros, <em>let me know what you'd use it for and I'll put it on github</em>.</p>
<div class="subscribe-form-wrapper">
  <form class="subscribe-form"
        action="https://lispcast.us4.list-manage.com/subscribe/post?u=a33b5228d1b5bf2e0c68a83f4&amp;id=d0f96276d9"
        method="POST"
        name="mc-embedded-subscribe-form"
        novalidate="true">
      <h3 class="subscribe-form-title">
        
Get free Clojure stuff and news on ClojureScript courses
</h3>
    
<img class="subscribe-form-image"
         src="http://www.lispcast.com/img/spaom-cover.jpg">
<div class="subscribe-form-text">
      <p class="subscribe-form-description">
        
The LispCast Single Page Applications with ClojureScript and Om course is in development <em>right now</em>! Sign up here to get news as it's being created and learn when it will launch. Also, you'll get to download all of the free stuff for learning and using Clojure.
</p>
      
<input id="mce-EMAIL.email-field"
             type="email"
             value=""
             placeholder="Email"
             name="EMAIL"> <input type="hidden"
             name="group[18565][64]"
             value="1">
<div style="position: absolute; left: -5000px;">
        
<input type="text"
               name="b_a33b5228d1b5bf2e0c68a83f4_d0f96276d9">
</div>
      
<input class="subscribe-button"
             type="submit"
             value="Get it"
             name="subscribe">
<div class="field-text-text2">
        
No spam. Ever.
</div>
    </div>
  </form>
</div>




<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/core-async-browser-motivation">core.async in Browsers</a></li>
<li><a href="http://www.lispcast.com/mastering-client-side-routing-with-secretary-and-goog-history">Mastering ClojureScript Routing with Secretary and goog.History</a></li>
</ul>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <div class="notes">

      </div>

    </div>

    <footer class="footer-banner">
    </footer>


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.0/lodash.min.js"></script>

    <script src="/js/mylibs/annotated-code.js"></script>

    <script>

      document.write('<script src="https://oberon.herokuapp.com/cookie/get.js?_=' + (new Date()).getTime() + '"><\/script>');

          if(window.oberon && mixpanel) {
          if(document.cookie.indexOf('oberon-id') < 0) {
                                                    var expires = (new Date((new Date().getTime() + 1000*60*60*24*365*10))).toUTCString();
                                                    mixpanel.alias(window.oberon.id);
                                                    document.cookie = "oberon-id=" + window.oberon.id + ";expires=" + expires + ";path=/";
                                                    }
                                                    mixpanel.identify(window.oberon.id);
                                                    }

                                                    mixpanel.register({URL: window.location.pathname,
                                                    Title: $("title").text()});

                                                    mixpanel.track("Page Visit");

                                                    mixpanel.track_forms('.gazette-form', 'Submit Clojure Gazette');
                                                    mixpanel.track_forms('.subscribe-form', 'Subscribe');

                                                    mixpanel.track_links('a.homepage-offer-box-link',
                                                    'Click PurelyFunctional.tv',
                                                    function(e) {
                                                    return {ToURL: $(e).prop('href')};
                                                    });

                                                    mixpanel.track_links('a.js-clojuregazette',
                                                    'Click Clojure Gazette',
                                                    function(e) {
                                                    return {ToURL: $(e).prop('href')};
                                                    });

                                                    $('input[name=EMAIL]').change(function() {
                                                    var i = $(this);
                                                    window.o_email = i.val();
                                                    });

                                                    $('form').submit(function() {
                                                    if(window.o_email)
                                                    mixpanel.people.set({"$email": window.o_email});
                                                    });

                                                    </script>

  </body>
</html>
