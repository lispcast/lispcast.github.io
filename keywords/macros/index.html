<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
    <link href='http://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>

    <title>Keyword: macros | LispCast</title>
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@ericnormand">
    <meta name="twitter:creator" content="@ericnormand">
    <meta name="twitter:description" content="A blog about the simple joys of functional programming.">
    <meta name="twitter:title" content="Keyword: macros">

    <meta property="og:title" content="Keyword: macros">
    <meta property="og:description" content="A blog about the simple joys of functional programming.">

    <meta name="description" content="A blog about the simple joys of functional programming.">

    <meta name="author" content="Eric Normand">

    <meta name="viewport" content="width=device-width,initial-scale=1">

    <!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/styles.css" type="text/css">

    <link rel="alternate" type="application/rss+xml"
    title="LispCast" href="/feed" />

    <!-- start Mixpanel --><script type="text/javascript">(function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
      for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);
                  mixpanel.init("ffad2bd88d2cb690edbbba6cf30b2958");</script><!-- end Mixpanel -->
                  </head>

  <body>
    <header class="banner">
      <h1 class="banner-logo">
        <a href="/">
          <img class="banner-logo-img"
               src="/img/Logo@2x.png"
               alt="LispCast" />
        </a>
      </h1>

      <div class="meta-data">
        <img class="bio-img"
             src="/img/eric_bio.jpg" />
        <a class="twitter-link"
           href="http://twitter.com/ericnormand">
          <i class="fa fa-twitter"></i>
        </a>
        <a class="github-link"
           href="https://github.com/ericnormand">
          <i class="fa fa-github"></i>
        </a>
        <a class="mail-link"
           href="mailto:eric@lispcast.com">
          <i class="fa fa-envelope"></i>
        </a>
        <a class="rss-link"
           href="/feed">
          <i class="fa fa-rss-square"></i>
        </a>
        <a class="rss-link"
           href="/archive.html">
          <i class="fa fa-list"></i>
        </a>
      </div>

    </header>

    <div class="main-container">


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/exponential-backoff">
            Exponential Backoff
          </a>
        </h2>

        <div class="timestamp">
          March 13, 2015
        </div>

        
<p>Summary: <em>A common failure in distributed systems is a server with a rate limit or with no limit but begins failing due to load. A standard solution is to retry after waiting a small time, increasing that time after each failure. We create a macro to handle this waiting and retrying.</em></p>
<p>A few days ago I wrote about <a href="http://www.lispcast.com/try-three-times">a high-level way of handing intermittent errors</a>, particularly in a distributed system. The way was simplistic: when you get an error, try again, up to a few errors. A slightly more nuanced approach is to <em>back off</em> before you try again. <strong>Each time there's an error, you wait longer, until some maximum time is reached.</strong></p>
<h2 id="the-problem">The problem</h2>
<p>Let's say you're hitting a service with a rate limit. That rate limit could be enforced or implicit<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. You've got lots of computers hitting it, and it's impossible to coordinate. No matter how hard you try to keep under that rate limit (and you <em>should try</em>), <strong>you will eventually break the limit</strong>. Retrying immediately when the server is too busy will actually make the problem worse. You will give it yet another request to deny. At the same time, it might be hard to distinguish &quot;I'm too busy <em>right now</em>&quot; from &quot;I'm never going to recover&quot;.</p>
<h2 id="the-solution">The solution</h2>
<p>I don't know what it's really called. I call it <em>Exponential Backoff</em>. It's also easy to turn into a separate routine:</p>
<pre><code>(defn exponential-backoff [time rate max f]
  (if (&gt;= time max) ;; we&#39;re over budget, just call f
    (f)
    (try
      (f)
      (catch Throwable t
        (Thread/sleep time)
        (exponential-backoff f (* time rate) rate max)))))</code></pre>
<p>This one has <strong>the same structure as <a href="http://www.lispcast.com/try-three-times"><code>try-n-times</code></a></strong> but will sleep before recursing. When it recurses, the time is multiplied by the rate. And when the last wait is more than the max, it will try one more time. Failures from that last try will propagate.</p>
<h3 id="how-to-use-it">How to use it</h3>
<p>Same as with <code>try-n-times</code>:</p>
<pre><code>(exponential-backoff 1000 2 10000
  #(http/get &quot;http://rate-limited.com/resource&quot;
             {:socket-timeout 1000
              :conn-timeout   1000}))</code></pre>
<p>This will retry after waiting 1 second (1000 ms) the first time, then double it (the <code>2</code>) each time. When it waits 10 seconds, it won't retry any more.</p>
<h3 id="slightly-more-useful">Slightly more useful</h3>
<p>Ok, so I don't use this exactly. What I use is slightly more complicated. I've found that <strong>I often can tell if it's a rate limiting problem if I look at the exception</strong>. So, let's pass it a predicate to check.</p>
<pre><code>(defn exponential-backoff [time rate max p? f]
  (if (&gt;= time max) ;; we&#39;re over budget, just call f
    (f)
    (try
      (f)
      (catch Throwable t
        (if (p? t)
          (do
            (Thread/sleep time)
            (exponential-backoff f (* time rate) rate max))
          (throw t))))))</code></pre>
<p>This one only recurses if the predicate returns true on the exception. Let's service mentions &quot;queue capacity&quot; in the body of the HTTP response when it's too busy:</p>
<pre><code>(exponential-backoff 1000 2 10000
  (fn [t] ;; the predicate
    (and (instance? clojure.lang.ExceptionInfo t)
         (re-find #&quot;queue capacity&quot; (:error (ex-data t)))))
  #(http/get &quot;http://rate-limited.com/resource&quot;
             {:socket-timeout 1000
              :conn-timeout   1000}))</code></pre>
<p><strong>You can be more selective about your backoff.</strong></p>
<h3 id="a-macro">A Macro</h3>
<p>Well, here's an example macro. It's got a bunch of defaults.</p>
<pre><code>(defmacro try-backoff [[time rate max p?] &amp; body]
  `(exponential-backoff (or ~time 1000) ;; defaults!
                        (or ~rate 2)
                        (or ~max 10000)
                        (or ~p? (constantly true))
                        (fn [] ~@body)))</code></pre>
<p>Here's how you use it:</p>
<pre><code>(try-backoff []
  (println &quot;trying!&quot;)
  (do-some-stuff))</code></pre>
<p>Also, add it to your Clojure Emacs config for better formatting, because this one wants the args on the first line:</p>
<pre><code>(put-clojure-indent &#39;try-backoff 1)</code></pre>
<p>This tells Emacs to make the second argument (<code>(println &quot;trying!&quot;)</code>) one indentation in, instead of directly under the first (<code>[]</code>).</p>
<h3 id="warning">Warning</h3>
<p>All of the <a href="http://www.lispcast.com/try-three-times#warning"><code>try3</code> warnings</a> apply. The stuff you're doing inside needs to be idempotent!</p>
<h3 id="conclusion">Conclusion</h3>
<p>This pattern is another cool, reusable component to help build reliability into a distributed system. Small, intermittent failures are pervasive. <strong>And a common form of error is a server being too busy.</strong> Being able to handle this type of error <strong>quickly and systematically</strong> is going to make your life easier.</p>
<p>Though Clojure does not have specific solutions to distributed systems problems, <strong>coding them up is short and straightforward</strong>. If you're interested in learning Clojure, I suggest you check out <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure</a>. It's a video course that uses animation, storytelling, and exercises to install Clojure into your brain.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>




<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/lisp-with-macros-language-stack">Lisp with Macros is Two Languages</a></li>
<li><a href="http://www.lispcast.com/try-three-times">Try Three Times</a></li>
<li><a href="http://www.lispcast.com/when-to-use-a-macro">When To Use a Macro in Clojure</a></li>
<li><a href="http://www.lispcast.com/pre-conj-david-pick">Pre-conj Prep: David Pick</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>meaning the server can only handle so many jobs at once, and the behavior is undefined at that point<a href="#fnref1">↩</a></p></li>
</ol>
</div>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/lisp-with-macros-language-stack">
            Lisp with Macros is Two Languages
          </a>
        </h2>

        <div class="timestamp">
          October 08, 2013
        </div>

        
<p>A Lisp with a macro system is actually two languages in a stack. The bottom language is the macro-less target language (which I'll call the Lambda language). It includes everything that can be interpreted or compiled directly.</p>
<p>The Macro language is a superset of the Lambda language. It has its own semantics, which is that Macro language code is recursively expanded into code of the Lambda language.</p>
<p>Why isn't this obvious at first glance? My take on it is that because the syntax of both languages is the same and the output of the Macro language is Lambda language code (instead of machine code), it is easy to see the Macro language as a feature of the Lisp. Macros in Lisp are stored in the dynamic environment (in a way similar to functions), are compiled just like functions in the Lisp language (also written in the Macro language) which makes it even easier to confuse the layers. It seems like a phase in some greater language which is the amalgam of the two.</p>
<p>However, it is very useful to see these as two languages in a stack. For one, realizing that macroexpansion is an interpreter (called <code>macroexpand</code>) means that we can apply all of our experience of programming language design to this language. What useful additions can be added? Also, it makes clear why macros typically are not first-class values in Lisps: they are not part of the Lambda language, which is the one in which values are defined.</p>
<p>
  <center>
  
<img src="http://www.lispcast.com/img/macro-stack.png" alt="Lisp stack showing both interpretation and compilation" />
</center>
</p>

<p>The separation of these two languages reveals another subtlety: that the macro language is at once an interpreter and a compiler. The semantics of the Macro language are defined to always output Lambda language, whereas the Lambda language is defined as an interpreter (as in <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.91.4527&amp;rep=rep1&amp;type=pdf">McCarthy's original Lisp paper</a>) and the compiler is an optimization. We can say that the Macro language has translation semantics.</p>
<p>But what if we define a stack that only allows languages whose semantics are simply translation semantics? That is, at the bottom there is a language whose semantics define what machine code it translates to. We would never need to explicitly write a compiler for that language (it would be equivalent to the interpreter). This is what I am exploring now.</p>
<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/exponential-backoff">Exponential Backoff</a></li>
<li><a href="http://www.lispcast.com/try-three-times">Try Three Times</a></li>
<li><a href="http://www.lispcast.com/when-to-use-a-macro">When To Use a Macro in Clojure</a></li>
<li><a href="http://www.lispcast.com/church-vs-curry-types">Church vs Curry Types</a></li>
</ul>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/try-three-times">
            Try Three Times
          </a>
        </h2>

        <div class="timestamp">
          March 05, 2015
        </div>

        
<p>Summary: <em>Distributed systems fail in indistinguishable ways. Often, retrying is a good solution to intermittent errors. We create a retry macro to handle the retries in a generic way.</em></p>
<p>Let's face it: your system is probably a distributed system. All web apps are by definition distributed. They have at least one server, probably a separate database server, and many browser clients. And now microservices are getting popular. Distributed is the current and future normal. While Clojure solves the problems of multiple cores sharing memory at the language level, <strong>distributed systems problems are left to be addressed at the application level</strong>.</p>
<h2 id="the-problem">The problem</h2>
<p>One big problem that comes up all the time in distributed systems is dealing with failure. Failure happens everywhere. The problem in a distributed system is that <strong>you don't know where the failure happened</strong>. For example, let's say you make an HTTP GET request and 20 seconds later, you're still waiting for the response. Is it:</p>
<ul>
<li>A network failure?
<ul>
<li>Did the message not get to the server?</li>
<li>Did the message get there, but the response didn't make it back?</li>
</ul></li>
<li>The server is down?</li>
<li>The server is still working?</li>
<li>The response is still coming?</li>
<li>An intermediate computer (proxy) has filtered the request/response?</li>
</ul>
<p>It is literally impossible to know what the problem is. And that's ok. There's a lot of machinery between one machine and the next. Even if you could diagnose the problem, <strong>are you really going to program each error case?</strong></p>
<h3 id="metaphor">Metaphor</h3>
<p>Let's say you call your friend and they don't pick up. Are they asleep? Is their phone off? Did the call not go through? The phone won't tell you. And you really want to talk to them. So what do you do? <strong>You call back.</strong> You might even call back a couple of times. If they pick up when you call back, great! If not, then you get tired and give up.</p>
<p>That's a common approach in distributed systems as well: retry your distributed message a few times before you give up. It's easy and <strong>fixes a surprising number of problems</strong>. What's more, there's a good solution that's <em>simple</em> in the Hickeyan sense.</p>
<h2 id="the-solution">The solution</h2>
<p><strong>Failure in Clojure typically means an Exception.</strong> So we'll need to catch exceptions and run code multiple times.</p>
<pre><code>(defn try-n-times [f n]
  (if (zero? n)
    (f)
    (try
      (f)
      (catch Throwable _
        (try-n-times f (dec n))))))</code></pre>
<p>You pass it a function and a number of times to retry it. The base case is when <code>n</code> is 0. In that case, it will just try it (not <em>re</em>try). If it's greater than 0, it will wrap the function call in a <code>try/catch</code>, catch everything, and recurse. If after n retries, is still throws an exception, <code>try-n-times</code> will fail and some other code will have to deal with it. <strong>The concern of retrying is separated from what is being retried.</strong></p>
<h3 id="how-do-you-use-it">How do you use it?</h3>
<p>Wrap your distributed calls in this bad boy and you're good to go.</p>
<p>Instead of this:</p>
<pre><code>(http/get &quot;http://somewhat-reliable.com/resource&quot;
          {:socket-timeout 1000
           :conn-timeout   1000})</code></pre>
<p>You do this:</p>
<pre><code>(try-n-times #(http/get &quot;http://somewhat-reliable.com/resource&quot;
                        {:socket-timeout 1000
                         :conn-timeout 1000}) 2)</code></pre>
<p>Remember, <code>n</code> is the number of <em>re</em>tries. So that's 1 <em>try</em> + 2 <em>re</em>tries.</p>
<h3 id="macro-anyone">Macro, anyone?</h3>
<p><strong>Alright, yes, I made a macro for that.</strong> It does come in handy to have a macro that you can put code in instead of passing in a function.</p>
<pre><code>(defmacro try3 [&amp; body]
  `(try-n-times (fn [] ~@body) 2))</code></pre>
<p>This one is used like this:</p>
<pre><code>(try3
  (println &quot;trying!&quot;)
  (do-some-stuff))</code></pre>
<h3 id="warning">Warning</h3>
<p>Now, a little care needs to be taken when you use this. Remember, when you get a failure, it could be a timeout. The server could be processing your request. Or it could have failed halfway through a multi-step process. What that means practically is that <strong>your distributed message has to be idempotent</strong>. HTTP GET <em>is</em> idempotent, so it's ok. POST generally is not, but sometimes it is. Use your judgment! Also, you should make your call timeout, to turn long waits into errors.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This pattern is just one piece of a larger distributed system puzzle. The network and servers are unreliable. They might work the whole time during development, but in the fullness of time, <strong>an always-on distributed system <em>will</em> have some kind of failure eventually</strong>. Sometimes the failures are temporary, and in those cases, a quick retry can fix it right away.</p>
<p>Though Clojure does not have specific solutions to distributed systems problems, coding them up is short and straightforward. If you're interested in learning Clojure, I suggest you check out <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure</a>. It's a video course that uses animation, storytelling, and exercises to install Clojure into your brain.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/exponential-backoff">Exponential Backoff</a></li>
<li><a href="http://www.lispcast.com/lisp-with-macros-language-stack">Lisp with Macros is Two Languages</a></li>
<li><a href="http://www.lispcast.com/when-to-use-a-macro">When To Use a Macro in Clojure</a></li>
<li><a href="http://www.lispcast.com/pre-conj-david-pick">Pre-conj Prep: David Pick</a></li>
</ul>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <article class="article">
        <h2 class="article-title-wrapper">
          <a class="article-title"
             href="/when-to-use-a-macro">
            When To Use a Macro in Clojure
          </a>
        </h2>

        <div class="timestamp">
          March 07, 2014
        </div>

        
<p>Summary: <em>Macros should be avoided to the extent possible. There are three circumstances where they are required.</em></p>
<p>There's a common theme in Lisp that you should only use macros when you need them. <strong>It is very common to see a new lisper overuse macros.</strong> I did it myself when I first learned Lisp. They are very powerful and make you the king of syntax.</p>
<p>Clojure macros do have their uses, but why should you avoid them if possible? The principle reason is that <strong>macros are not first-class in Clojure</strong>. You cannot access them at runtime. You cannot pass them as an argument to a function, nor do any of the other powerful stuff you've come to love from functional programming. In short, <strong>macros are not functional programming</strong> (though they can make use of it).</p>
<p>A function, on the other hand, is a first-class value, and so is available for awesome functional programming constructs. <strong>You should prefer functions to macros.</strong></p>
<p>That said, macros are still useful because there are things macros can do that functions cannot. <strong>What are the powers of a macro that are unavailable to any other construct in Clojure?</strong> If you <em>need</em> any of these abilities, write a macro.</p>
<h3 id="the-code-has-to-run-at-compile-time">1. The code has to run at compile time</h3>
<p>There are just some things that need to happen at compile time. I recently wrote a macro that returns the hash of the current git commit so that the hash can be embedded in the ClojureScript compilation. This needs to be done at compile time because the script will be run somewhere else, where it cannot get the commit hash. Another example is <strong>performing expensive calculations at compile time as an optimization</strong>.</p>
<p>Example:</p>
<pre><code>(defmacro build-time []
  (str (java.util.Date.)))</code></pre>
<p>The <code>build-time</code> macro returns a String representation of the time it is run.</p>
<p><strong>Running code at compile time is not possible in anything other than macros.</strong></p>
<h3 id="you-need-access-to-unevaled-arguments">2. You need access to unevaled arguments</h3>
<p>Macros are useful for writing <strong>new, convenient syntactic constructs</strong>. And when we talk about syntax, we are typically talking about raw, <strong>unevaluated sexpressions</strong>.</p>
<p>Example:</p>
<pre><code>(defmacro when
  &quot;Evaluates test. If logical true, evaluates body in an implicit do.&quot;
  {:added &quot;1.0&quot;}
  [test &amp; body]
  (list &#39;if test (cons &#39;do body)))</code></pre>
<p><code>clojure.core/when</code> is a syntactic sugar macro which transforms into an <code>if</code> with a <code>do</code> for a <em>then</em> and no <em>else</em>. The <code>body</code> should not be evaled before the <code>test</code> is checked.</p>
<p>Getting access to the unevaluated arguments is available by quoting (<code>'</code> or <code>(quote ...)</code>), but that is <strong>often unacceptable for syntactic constructs</strong>. Macros are the only way to do that.</p>
<h3 id="you-need-to-emit-inline-code">3. You need to emit inline code</h3>
<p>Sometimes calling a function is unacceptable. That call is either too expensive or is otherwise not the behavior you want.</p>
<p>For instance, in Javascript in the browser, you can call <code>console.log('msg')</code> to print out a message and the line number to the console. In ClojureScript, this becomes something like this: <code>(.log js/console &quot;msg&quot;)</code>. Not convenient at all. <strong>My first thought was to create a function.</strong><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup></p>
<pre><code>(defn log [msg]
  (.log js/console msg))</code></pre>
<p>This worked alright for printing the message, but the line numbers were all pointing to the same line: the body of the function! <code>console.log</code> records the line exactly where it is called, so <strong>it needs to be inline</strong>. I replaced it with a macro, which highlights its purpose as syntactic sugar.</p>
<p>Example:</p>
<pre><code>(defmacro log [msg]
  `(.log js/console ~msg))</code></pre>
<p>The body replaces the call to log, so <strong>it is located where it is needed for the proper behavior.</strong></p>
<p>If you need <strong>inline code</strong>, a macro is the only way.</p>
<h3 id="other-considerations">Other considerations</h3>
<p>Of course, <strong>any combination of these is also acceptable</strong>. And don't forget that although you might need a macro, macros are only available at compile time. So you should consider <strong>providing a function that does the same thing</strong> and then wrap it with a macro.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Macros are very powerful. Their power comes with a price: they are only available at compile time. Because of that, functions should be preferred to macros. The use of macros should be reserved for those special occasions when their power is needed.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>


<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/exponential-backoff">Exponential Backoff</a></li>
<li><a href="http://www.lispcast.com/lisp-with-macros-language-stack">Lisp with Macros is Two Languages</a></li>
<li><a href="http://www.lispcast.com/try-three-times">Try Three Times</a></li>
<li><a href="http://www.lispcast.com/3-things-java-can-steal-from-clojure">3 Things Java Programmers Can Steal from Clojure</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>As it should be :)<a href="#fnref1">↩</a></p></li>
</ol>
</div>


        <div class="endmark">
          <a class="endmark-link"
             href="/">
            <img class="endmark-lambda"
                 src="/img/lambda.png" />
          </a>
        </div>

      </article>


      <div class="notes">

      </div>

    </div>

    <footer class="footer-banner">
    </footer>


    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <script>

      document.write('<script src="https://oberon.herokuapp.com/cookie/get.js?_=' + (new Date()).getTime() + '"><\/script>');

          if(window.oberon && mixpanel) {
          if(document.cookie.indexOf('oberon-id') < 0) {
                                                    var expires = (new Date((new Date().getTime() + 1000*60*60*24*365*10))).toUTCString();
                                                    mixpanel.alias(window.oberon.id);
                                                    document.cookie = "oberon-id=" + window.oberon.id + ";expires=" + expires + ";path=/";
                                                    }
                                                    mixpanel.identify(window.oberon.id);
                                                    }

                                                    mixpanel.register({URL: window.location.pathname,
                                                    Title: $("title").text()});

                                                    mixpanel.track("Page Visit");

                                                    mixpanel.track_forms('.gazette-form', 'Submit Clojure Gazette');
                                                    mixpanel.track_forms('.subscribe-form', 'Subscribe');

                                                    mixpanel.track_links('a.homepage-offer-box-link',
                                                    'Click PurelyFunctional.tv',
                                                    function(e) {
                                                    return {ToURL: $(e).prop('href')};
                                                    });

                                                    mixpanel.track_links('a.js-clojuregazette',
                                                    'Click Clojure Gazette',
                                                    function(e) {
                                                    return {ToURL: $(e).prop('href')};
                                                    });

                                                    $('input[name=EMAIL]').change(function() {
                                                    var i = $(this);
                                                    window.o_email = i.val();
                                                    });

                                                    $('form').submit(function() {
                                                    if(window.o_email)
                                                    mixpanel.people.set({"$email": window.o_email});
                                                    });

                                                    </script>

  </body>
</html>
