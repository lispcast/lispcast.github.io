<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>LispCast</title>
    <meta name="description" content="A blog about the simple joys of functional programming.">
    <meta name="author" content="Eric Normand">

    <meta name="viewport" content="width=device-width,initial-scale=1">

    <!--[if lt IE 9]>
        <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/styles.css" type="text/css">

    <link rel="alternate" type="application/rss+xml" title="LispCast" href="/feed" />

<!-- start Mixpanel --><script type="text/javascript">(function(f,b){if(!b.__SV){var a,e,i,g;window.mixpanel=b;b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!==typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");
for(g=0;g<i.length;g++)f(c,i[g]);b._i.push([a,e,d])};b.__SV=1.2;a=f.createElement("script");a.type="text/javascript";a.async=!0;a.src="//cdn.mxpnl.com/libs/mixpanel-2.2.min.js";e=f.getElementsByTagName("script")[0];e.parentNode.insertBefore(a,e)}})(document,window.mixpanel||[]);
mixpanel.init("ffad2bd88d2cb690edbbba6cf30b2958");</script><!-- end Mixpanel -->
  </head>

  <body>
    <header class="banner">
      <h1 class="banner-logo">
        <a href="/">
          <img class="banner-logo-img"
               src="/img/Logo@2x.png"
               alt="LispCast" />
        </a>
      </h1>

      <div class="meta-data">
        <img class="bio-img"
             src="/img/eric_bio.jpg" />
        <a class="twitter-link"
           href="http://twitter.com/ericnormand">
          <i class="fa fa-twitter"></i>
        </a>
        <a class="github-link"
           href="https://github.com/ericnormand">
          <i class="fa fa-github"></i>
        </a>
        <a class="mail-link"
           href="mailto:eric@lispcast.com">
          <i class="fa fa-envelope"></i>
        </a>
        <a class="rss-link"
           href="/feed">
          <i class="fa fa-rss-square"></i>
        </a>
        <a class="rss-link"
           href="/archive.html">
          <i class="fa fa-list"></i>
        </a>
      </div>

    </header>

    <div class="main-container">


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/just-hack-something-together">
              Just Hack Something Together
            </a>
          </h2>

          <div class="timestamp">
            September 04, 2014
          </div>

          
<p>Summary: <em>Lisp is viewed as difficult and academic but it is a great language for hacking a solution together.</em></p>
<p>I used to be in a carpool with other developers. We would drive an hour to work each way. And sometimes we'd talk about programming languages. Once I was talking about why Common Lisp wasn't more popular. Someone answered <strong>&quot;people just want to hack something together&quot;</strong>.</p>
<p>That took a while to unpack and it felt like many conversations I had with that group. Without exploding all of the context, I'll just say that he meant that <strong>Common Lisp was less amenable to quickly building a solution than Java</strong><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. That notion caused my head to spin and I didn't know how to respond.</p>
<p>So I'll respond here, now (5 or 6 years later!). <strong>Lisp was made to explore solutions quickly.</strong> Lisp is often seen as a difficult, academic language. But Lisp has several things that make it a beautiful language for hacking a solution together.</p>
<h3 id="the-repl">1. The REPL</h3>
<p><strong>You can type code in and it will run.</strong> Right there. The entire language is available without having to open a text file. You can experiment on a solution, testing as you go. This is much faster than having to write a main method.</p>
<h3 id="incremental-compilation">2. Incremental compilation</h3>
<p>You can redefine a function. Any code that calls that function will now use the new definition. You no longer have the edit-compile-run cycle. <strong>You can make changes and fixes much faster.</strong></p>
<h3 id="data-structures">3. Data structures</h3>
<p><strong>Even the humble Lisp list is better than most of what Java gives you.</strong> Lists can represent linear data, trees, or associative data. But more importantly, the interface is powerful. There are many operations built to use lists, so you're compounding effectiveness on top of everything built in. And if you bring in Clojure's data structures, there's no comparison.</p>
<p>In Java, you can use Lists and Maps. But most of the time, people will create a new class to represent their data. And <strong>making a new class means you have to write all of the methods</strong>. And that is definitely slower than using an existing data structure with existing methods.</p>
<h3 id="less-code">4. Less code</h3>
<p><strong>Lisp is less verbose than Java.</strong> If you're trying to go quickly, one limiting factor is how fast you can type the code in.</p>
<p>I purposefully left out a lot of the features of Lisp that make it great because some of them are considered &quot;advanced&quot;. I want to keep the list down to <strong>those basic things that you're going to have to use in order to use the language</strong>. The &quot;advanced&quot; features require expertise in order to be more efficient at them. <strong>You can be more effective in Lisp with a small cheatsheet of syntax and functions.</strong></p>
<p>I think it's pretty clear that <strong>Lisp is superior to Java for &quot;hacking&quot;</strong>. It was developed to experiment with programs interactively. And it serves that purpose very well. If you think you'd like to learn a modern Lisp, I suggest learning from <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure</a>. It's a great video series that takes you from zero knowledge to a deep understanding of functional programming.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/infinite-application">Infinite Application</a></li>
<li><a href="http://www.lispcast.com/a-personal-lisp-crisis">A Personal Lisp Crisis</a></li>
<li><a href="http://www.lispcast.com/pre-west-jeanine-adkisson">Pre-West Prep: Jeanine Adkisson</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I don't mean to pick on Java, it was his language of choice. Having a comparison language merely helps the imagination<a href="#fnref1">â†©</a></p></li>
</ol>
</div>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/atom-problem">
              Atom code explanation
            </a>
          </h2>

          <div class="timestamp">
            August 28, 2014
          </div>

          
<p>Summary: <em>I go over a real-world example of how atoms and immutable values allow you to compose constructs in ways that are easy to reason about and less prone to error.</em></p>
<p>The other day I was in IRC #clojure and someone asked a good question. They had code like the following, and they couldn't understand why <strong>they couldn't modify a map</strong>.</p>
<pre><code>(def state (atom {}))

(doseq [x [1 2 3]]
  (assoc @state :x x))

(println @state)
</code></pre>
<p>What does this print? Well, the asker wanted it to print <code>{:x 3}</code>. But it printed <code>{}</code>. To understand what's happening, <strong>let's go step by step</strong>.</p>
<p><code>{}</code> creates an empty map. It's literal syntax for a <em>constructor</em> for a map. This one happens to be empty.</p>
<p><code>(atom {})</code> takes the empty map that was just created and passes it to the function <a href="http://grimoire.arrdem.com/1.6.0/clojure.core/atom/"><code>atom</code></a>, which constructs a new <code>clojure.lang.Atom</code>. Atoms are objects, and its current state is the empty map we just passed in.</p>
<p><code>(def state (atom {}))</code> defines a new var called <code>state</code> in the current namespace.</p>
<p>At this point, we've got a variable called <code>state</code> whose value is an atom that holds an empty map.</p>
<p><code>(doseq [x [1 2 3]]</code> loops over the numbers 1, 2, and 3. <code>x</code> will be bound to each of those numbers, in turn.</p>
<p><code>@state</code> gets transformed into <code>(deref state)</code>, which returns the current value of <code>state</code>. <code>:x</code> is a literal keyword, and <code>x</code> is a reference to the <code>x</code> bound inside the loop.</p>
<p><code>(assoc @state :x x)</code> creates a <em>new map</em> by taking the current value of <code>state</code> (which happens to be <code>{}</code>) and associating <code>:x</code> with <code>x</code> (which will be <code>1</code>, <code>2</code>, and <code>3</code> as the loop happens). The value is returned by <a href="http://grimoire.arrdem.com/1.6.0/clojure.core/assoc"><code>assoc</code></a>, and then thrown away, since it isn't bound to anything.</p>
<p>Then <code>(println @state)</code> will print the current value of <code>state</code>, which still is <code>{}</code>.</p>
<p>This code shows a common problem that beginners face in Clojure: how do <strong>immutable data structures</strong> (like maps) and the <strong>concurrency primitives</strong> (like <code>atom</code>) work together to manage state?</p>
<p>The answer is quite simple (<a href="http://www.infoq.com/presentations/Simple-Made-Easy">in the Rich Hickeyan sense</a>) and elegant. <strong>By separating the ideas of value and state, Clojure has made it easy to express precisely the behavior you want in concurrent systems.</strong></p>
<p>The value is the map. It is immutable. It cannot change. It is a single value, and it will always be the same. That means <strong>threads can share the value with no worries that one of them will change it</strong>.</p>
<p>The state is the atom. It's a mutable object. And being an object, it has methods that define its interface. In the code above, we saw that you can call <a href="http://grimoire.arrdem.com/1.6.0/clojure.core/deref"><code>deref</code></a> on an atom to get its current value. <code>deref</code> is basically a getter.</p>
<p>The main way to <em>change</em> the value of an atom is using <a href="http://grimoire.arrdem.com/1.6.0/clojure.core/swap!"><code>swap!</code></a>. <code>swap!</code> takes an atom and a function (plus optional arguments) and <strong>calls the function on the current value of the atom</strong>. It then sets the value of the atom to the return value of the function. So let's use that to fix the code.</p>
<pre><code>
(def state (atom {}))

(doseq [x [1 2 3]]
  (swap! state assoc :x x))

(println @state)
</code></pre>
<p><code>swap!</code> takes the atom (<code>state</code>) and a function (<code>assoc</code>) and some arguments (<code>:x x</code>). It calls <code>assoc</code> on the current value of <code>state</code> with those extra arguments and sets the value of the atom to the return value of the function.</p>
<p>The <code>swap!</code> expression is almost (but not) the same as this code:</p>
<pre><code>
(reset! state (assoc @state :x x)) ;; never do this
</code></pre>
<p><a href="http://grimoire.arrdem.com/1.6.0/clojure.core/reset!"><code>reset!</code></a> changes the state of the atom but without regard to the current value. This new code is bad because it's not thread-safe. <strong>Use <code>swap!</code> if you need to use the current value to determine the new value.</strong></p>
<p>So what does an atom do? What does it represent?</p>
<p>Atoms guarantee one very important thing: that <strong>each state is calculated from the last state</strong>. The <code>swap!</code> operation is <em>atomic</em>. No matter how many threads are trying to change the value, each change is calculated from the previous value and no previous values are lost. That's its contract as an object and it's one of the important ways that <strong>Clojure helps with concurrency</strong>.</p>
<p>How can a value be lost?</p>
<p>If we have two threads, each trying to change <code>state</code> in the same incorrect way (using <code>reset!</code>), the order of evaluation will have several steps:</p>
<ol style="list-style-type: decimal">
<li><code>(deref state)   ;; call this value *1</code></li>
<li><code>(assoc *1 :x x) ;; call this value *2</code></li>
<li><code>(reset! state *2)</code></li>
</ol>
<p>Because the threads are running concurrently, the operations have a chance of interleaving their steps in unwanted ways. For instance, threads A and B might interleave like this:</p>
<ol style="list-style-type: decimal">
<li>A: <code>(deref state)    ;; call this value *1A</code></li>
<li>A: <code>(assoc *1A :x x) ;; call this value *2A</code></li>
<li>B: <code>(deref state)    ;; call this value *1B</code></li>
<li>B: <code>(assoc *1B :x x) ;; call this value *2B</code></li>
<li>B: <code>(reset! state *2B)</code></li>
<li>A: <code>(reset! state *1A)</code></li>
</ol>
<p>What happened? On line 6, A set the value of <code>state</code> to the value it calculated on line 2. So <strong>B's work is completely discarded</strong>. That's probably not what was intended. What's worse is that that is one of many possible interleavings, some of which work and some don't. Welcome to concurrency!</p>
<p>What you probably wanted was to make sure that <em>no</em> work is discarded. You want the operation to be <em>atomic</em>. That's why it's called an atom. <code>swap!</code> is atomic. A <code>swap!</code> to an atom occurs &quot;all at once&quot;, instead of on three lines like the <code>reset!</code> example. If two threads are doing <code>swap!</code>, there are two possible interleavings.</p>
<ol style="list-style-type: decimal">
<li>A: <code>(swap! state assoc :x x)</code></li>
<li>B: <code>(swap! state assoc :x x)</code></li>
</ol>
<p>And</p>
<ol style="list-style-type: decimal">
<li>B: <code>(swap! state assoc :x x)</code></li>
<li>A: <code>(swap! state assoc :x x)</code></li>
</ol>
<p>These are usually what you want. If <em>only one</em> or <em>neither one</em> works, <strong>atom is not the right construct for you</strong>.</p>
<p>So there you go. Atomic mutable state with immutable values gives you a nice, <strong>composable concurrency semantics</strong>. You could do it with locks but it's harder to ensure you're doing it correctly. It's slightly higher-level than locks yet it provides tremendous value. <strong>Atoms are easier to reason about and less prone to errors.</strong></p>
<p>If you'd like to learn the basics of Clojure, I recommend my video course called <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure</a>. I don't go over concurrency, but you will learn lots of functional programming. Go check out <a href="http://www.purelyfunctional.tv/intro-to-clojure">the description</a> to see if it's right for you.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/3-things-java-can-steal-from-clojure">3 Things Java Programmers Can Steal from Clojure</a></li>
<li><a href="http://www.lispcast.com/clojure-database-test-faster">How I made my Clojure database tests 5x faster</a></li>
<li><a href="http://www.lispcast.com/clojure-gazette-looking-forward-2015">Clojure Gazette Looking Forward</a></li>
<li><a href="http://www.lispcast.com/clojure-is-imperative">Clojure is Imperative</a></li>
</ul>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/two-kinds-of-bootstrapping">
              Two Kinds of Bootstrapping
            </a>
          </h2>

          <div class="timestamp">
            August 23, 2014
          </div>

          
<p>Summary: <em>I like languages with a small core that is extensible. The languages tend to be weird and require less code to bootstrap.</em></p>
<p>I know of two ways to bootstrap a language.</p>
<p>The first way is probably more traditional. I'll call the first way Type 1. In Type 1, you write a bare-minimum compiler for your language in a host language. So maybe you write a Lua compiler in C. Then you write a Lua compiler in Lua. Then you compile your compiler. Now you have a compiler, written in Lua. You can add to it and modify it without ever having to touch the C code again. You have the advantage of writing the features of your language (Lua) in a higher-level language (Lua). And finally, as you add features to your compiler, you can use those to add more features. There's some leverage.</p>
<p>I like the second way better. I'll call it Type 2. In Type 2, you write a small, powerful set of abstractions in the host language. For instance, you write an <a href="http://piumarta.com/software/id-objmodel/">object system in C</a>, a <a href="https://github.com/AlexandreAbreu/jonesforth/blob/master/jonesforth.S">stack and dictionary in assembler</a>, or <a href="https://github.com/clojure/clojure/blob/34258286c5bc3cc72ca212fceb34e6d61359cb1b/src/jvm/clojure/lang/Compiler.java#L3740">lexical closures in Java</a>. Then you write a compiler that targets those abstractions. If the abstractions are chosen correctly, your compiler is done. You can begin building abstraction on top of abstraction without touching the compiler.</p>
<p>There are a few things to note:</p>
<ol style="list-style-type: decimal">
<li><p>Type 2 languages (Lisp, Smalltalk, FORTH) tend to be weird because they were birthed in a different way. The abstractions, though powerful, are often raw.</p></li>
<li><p>Type 2 languages can be bootstrapped faster. The core is often much smaller than a full-featured compiler.</p></li>
<li><p>Type 2 languages tend to require less code in general. I guess it's because you're writing most of it in a language that is compounding leverage.</p></li>
<li><p>Type 2 languages are more easily ported, since all you have to do is rewrite the core. Type 1 languages, depending on how they are built, can require you to re-bootstrap or write a cross-compiler.</p></li>
</ol>
<p>In the end, I believe that both Type 1 and Type 2 are viable options for language-building. I prefer Type 2. If Type 2 intrigues you, you should learn Lisp (or FORTH or Smalltalk). I recommend the <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure videos course</a>.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/clojure-is-imperative">Clojure is Imperative</a></li>
<li><a href="http://www.lispcast.com/church-vs-curry-types">Church vs Curry Types</a></li>
<li><a href="http://www.lispcast.com/css-abstraction-combination">CSS has Weak Forms of Abstraction and Combination</a></li>
<li><a href="http://www.lispcast.com/less-abstraction-combination">LESS has Better Forms of Abstraction than CSS</a></li>
</ul>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/clojure-is-imperative">
              Clojure is Imperative
            </a>
          </h2>

          <div class="timestamp">
            August 22, 2014
          </div>

          
<p>Summary: <em>Clojure is an imperative language. Its operations are defined in terms of concrete actions. But those actions are often the same actions available to the programmer at runtime. This makes it easy to bootstrap.</em></p>
<p>Update: <em><a href="http://twitter.com/bitemyapp">Ø£Ø®Ù„Ø§Ù‚ Ø§Ù„Ø®ÙŠÙ…ÙŠØ§Ø¦ÙŠ</a> pointed out that I was wrong about the size of GHC. Luckily it was not salient to my point so I just removed that part of the article.</em></p>
<p>Update: <em>After talking with several people, I've decided that my writing was really unclear. I've done some major editing to make it as clear as I can. Thanks to everyone who commented and helped me clarify my thinking and writing.</em></p>
<p>I was recently <a href="http://blog.cognitect.com/cognicast/062-eric-normand">on the Cognicast</a> and I mentioned something really important to me, but I did not go that deep into it.</p>
<p>Clojure, and Lisps in general, are <em>imperative languages</em>. Yes, they are good for doing <a href="http://www.lispcast.com/what-is-functional-programming"><em>functional programming</em></a>, but their <strong>main paradigm is executing lists of commands in order</strong>.</p>
<p>On the podcast I mentioned the first imperative example that came to mind, which was the <code>do</code> form, which executes each expression in the body and returns the value of the last expression. <strong>You would only want to execute an expression and throw away its value for its <em>side effects</em>.</strong></p>
<p>But why is that important to me? It got me thinking about a deeper but related idea.</p>
<p>Clojure is a <em>relatively</em> transparent layer above the JVM. I say &quot;relatively&quot; because languages do get quite a bit more opaque<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>. But it manages to be powerful through well-chosen abstractions.</p>
<p>I should be a little more specific about what I mean by &quot;transparent&quot; and &quot;opaque&quot;. This should be the most controversial part of this post, so I want to get this right. These are not formal definitions. <strong>Transparency/opaqueness measures abstractions.</strong> Opaque abstractions show less of the underlying machinery. Transparent abstractions show their machinery. This is a spectrum.<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p>Clojure's functions are rather opaque. Defining a function (with <code>fn</code>) in Clojure creates a class and instantiates it with the values from its lexical environment. This happens without having to think about classes. You're not thinking about the machinery. The machinery leaks out sometimes, like when you're looking at stack traces. But in general, an illusion is maintained.</p>
<p>But Clojure's <code>def</code> form is pretty transparent. You do have to think about what it's doing, about the current namespace, the order of the <code>defs</code> in a namespace, etc. There is not much of an illusion to maintain.</p>
<p>Haskell has a well-defined execution semantics. It's formally defined and you can step through the execution of a Haskell program by hand if you want. In that sense, it's imperative. But the execution order is obscured by the somewhat opaque abstraction of <em>lazy evaluation</em>. <strong>Clojure's execution order is more or less directly the execution order of the JVM it runs on--hence more transparent.</strong></p>
<p>The reason this is important is that <strong>Clojure's strategy is to be transparent</strong> unless there is significant gain. This is part of what is meant by &quot;embracing the host&quot;. Haskell's strategy is orthogonal to the transparency/opaqueness axis. Haskell aims to be formally well-defined. Formal semantics allows deep static analysis and program transformation.</p>
<p>Besides the strategy of being transparent, what I like even more about Clojure is that the <strong>many abstractions are <em>defined in the same abstractions</em> that you have available as a programmer</strong>.</p>
<p>This is from the <a href="http://grimoire.arrdem.com/1.6.0/clojure.core/def/">docstring of def</a>:</p>
<blockquote>
<p>Creates and interns a global var with the name of symbol in the current namespace (*ns*) or locates such a var if it already exists. If init is supplied, it is evaluated, and the root binding of the var is set to the resulting value. If init is not supplied, the root binding of the var is unaffected.</p>
</blockquote>
<p>Creating a var? I can do that. Interning it? I can do that, too. Setting the root binding? Easy! The core can be kept minimal because abstractions can build on each other. If you get the abstractions right, the amount of code you have to write in your implementation language is small.</p>
<p>And this gets to the heart of it: <em>you</em> can write a Lisp yourself. Many people have. You can <strong>write an easy Lisp compiler in a weekend</strong> and build features on top of it, almost <strong>never having to change the original compiler</strong>.</p>
<p>This is the magic of <a href="http://www.lispcast.com/two-kinds-of-bootstrapping">bootstrapped languages</a> like Lisps. They have a <strong>small core that you need to get right, then everything else can be written in that core</strong>. It's the ultimate minimal virtual machine.</p>
<p>What's the relationship between bootstrapping and transparency? <strong>The more opaque the abstractions, the more the language must do to maintain the illusion.</strong> Lisps are easy to bootstrap because the abstractions chosen are either transparent and trivial to implement (like <code>def</code> or <code>if</code>) or opaque and powerful (like <code>fn</code>).</p>
<p>I like Lisps (and Clojure) because <strong>I feel that I can understand them and build them myself</strong>. I don't <em>actually</em> understand everything, but I <em>could</em> if I tried. Somewhere along the way I developed a deep interest in bootstrapping. <strong>Bootstrapping is compounded leverage.</strong> You build small abstractions on top of the previous ones, and use those to build yet grander ones.</p>
<p>If you like this attitude toward programming languages, <strong>you should learn a Lisp</strong>. I suggest Clojure, and I recommend the <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure video series</a>. You'll learn about building up powerful abstractions, one layer at a time, in a small amount of code.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/3-things-java-can-steal-from-clojure">3 Things Java Programmers Can Steal from Clojure</a></li>
<li><a href="http://www.lispcast.com/atom-problem">Atom code explanation</a></li>
<li><a href="http://www.lispcast.com/clojure-database-test-faster">How I made my Clojure database tests 5x faster</a></li>
<li><a href="http://www.lispcast.com/clojure-gazette-looking-forward-2015">Clojure Gazette Looking Forward</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are more transparent languages as well, but they tend to be obscure.<a href="#fnref1">â†©</a></p></li>
<li id="fn2"><p>As an aside to those who read previous versions of this post, what I meant by imperative/declarative was transparent/opaque. I botched it and I'm trying to get this idea right.<a href="#fnref2">â†©</a></p></li>
</ol>
</div>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/complex-syntax">
              Complex Syntax
            </a>
          </h2>

          <div class="timestamp">
            August 19, 2014
          </div>

          
<p>Summary: <em>Lisps are revered for their simple syntax, but parens are complex. They complect function calls and macro calls, which have drastically different semantics.</em></p>
<p>One of the problems that people have with Lisps is that they hate the parentheses. Clojure does a pretty good job of minimizing unnecessary parens and giving them a much clearer meaning. But there's a deeper problem that people express all the time when they're first learning. It's frustrating to watch people struggle with it, because it's not their fault. <strong>It's a problem with Lisps in general.</strong></p>
<p>Parens in all Lisps I've seen, including Clojure, are complex. I'm not using the word lightly. <strong>Parens complect two similar but distinct ideas: macro application and function application.</strong></p>
<p>Macros and functions are obviously different. Macros are expanded at a time just before compilation called &quot;macro-expansion time&quot;. They typically cannot be accessed at runtime. Functions, on the other hand, are applied at runtime. And they are first-class, meaning they are runtime values. In addition, the calling semantics are different. Macros are call-by-name. The code of each gets passed unevaluated. Functions are call-by-value. <strong>Functions and macros are two distinct species.</strong></p>
<p>However, despite being distinct semantics, the syntax for calling the two is identical. Parens complect applying macros with applying functions. Beginners trip up on this all the time. Their head is already spinning from the notion that some of the things they are learning are macros, called at compile time. Now add on top that the syntax of the language does not help one bit in distinguishing macro calls from function calls. <strong>You just have to memorize what's a macro and what's a function.</strong></p>
<p>We learned in <a href="http://www.thecorememory.com/Next_700.pdf">The Next 700 Programming Languages</a> that our syntax should serve to elucidate the semantics. Lisp just fails at this pretty hard. The only consolation is that <strong>you actually can remember, with time and experience, what's a macro and what's a function</strong>. Every Lisp programmer is proof of that.</p>
<p>A simple solution would be to have <strong>a weird syntax for calling macros</strong>. You know, instead of parens, you use something else. Something that distinguishes the two to decomplect them. This would have broad and deep implications for the language that I cannot begin to fathom.</p>
<p>The takeaway for the beginner is that, sorry, Clojure won't help you much with this, but <strong>it's very important to know what's a macro and what's a function</strong>. You just have to keep track in your head. If you're not sure, you can call <code>clojure.repl/doc</code><sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> on any symbol. If it names a macro, it will tell you.</p>
<p>So, there you have it. <strong>Lisps complect function calls and macro calls</strong>, which have drastically different semantics, using the same notation. Common Lisp and Scheme use parens for much more than that, making the syntax complex and context-dependent<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup>. Clojure removes a lot of those parens, replacing them with square braces or removing them altogether. However, the complexity of macro and function calls remains.</p>
<p>Despite this, Clojure is still a great language! If you'd like to learn Clojure, I have to recommend the <a href="http://purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure</a> video series.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/3-things-java-can-steal-from-clojure">3 Things Java Programmers Can Steal from Clojure</a></li>
<li><a href="http://www.lispcast.com/atom-problem">Atom code explanation</a></li>
<li><a href="http://www.lispcast.com/clojure-database-test-faster">How I made my Clojure database tests 5x faster</a></li>
<li><a href="http://www.lispcast.com/clojure-gazette-looking-forward-2015">Clojure Gazette Looking Forward</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>That's a macro.<a href="#fnref1">â†©</a></p></li>
<li id="fn2"><p>For instance, inside of a <code>let</code>, parens take on the meaning of grouping the bindings and also grouping the variable with its value.<a href="#fnref2">â†©</a></p></li>
</ol>
</div>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/is-core-async-against-clojure-philosophy">
              Is core.async Against the Clojure Philosophy?
            </a>
          </h2>

          <div class="timestamp">
            August 06, 2014
          </div>

          
<p>Summary: <em>Clojure core.async is a way to manage mutable state. Isn't that against functional programming?</em></p>
<p>When core.async was first announced, there was a lot of fanfare. But among the celebration, there was some consternation about core.async. <strong>Isn't core.async against the functional principles of Clojure?</strong> Aren't channels just mutable state? Aren't the <code>&lt;!</code> and <code>&gt;!</code> operations mutation?</p>
<p>Well, it's true. core.async is about mutation. <strong>It's procedural code.</strong> Go blocks run their bodies one step at a time. It's imperative.</p>
<p>But that's what Clojure is all about. It <strong>makes functional programming easy</strong> (with <code>fn</code>s, immutable data structures, and higher order functions). It also makes mutable state <em>easy to reason about</em>. It does not eliminate it. <strong>It simply gives you better abstractions.</strong> That's what Atoms, Refs, Vars, and Agents are: useful abstractions for dealing with state.</p>
<p>core.async is just another abstraction for dealing with state. But, following the Clojure philosophy, it was chosen to be easy to reason about. <strong>The hardest part about coordinating and communicating with independent threads normally is that neither of them know what the other is doing.</strong> You can make little signals using shared memory. But those signals get complicated fast once you scale past two threads.</p>
<p>And that's what a channel is: it's just <strong>a shared coordination point</strong>. But it has some cool properties that make it super easy to reason about:</p>
<ol>
<li>Carry semantics: the channel carries its own coordination semantics (buffering, unbuffered, etc).</li>
<li>Simple interface: channels have put, take, and close. That's it.</li>
<li>Very scalable: any number of processes can use a single channel with no additional cost.</li>
<li>Decoupling: consumers don't need to know producers and <em>vice versa</em>.</li>
</ol>
<p>Channels are awesome, but they're not the whole story. The other part of core.async is the go block. <a href="http://www.lispcast.com/core-async-browser-motivation">Go blocks are another abstraction</a>. They allow you to <strong>write code in an imperative style that blocks on channels</strong>. You get to use loops and conditionals, as well as local let variables, global variables, and function calls -- everything you're already using, but augmented with the coordination power of channels.</p>
<p>All of these features add up to something you can reason about <em>locally</em>. That's the key: <strong>the code you're looking at now can be understood without looking at other code</strong>.</p>
<p>But there's a downside: you now have more choices. In theory, they're easier choices. But that requires you to understand the choices. <strong>You need to understand the abstractions, the idioms, and the tradeoffs.</strong> That's the goal of the <a href="http://www.purelyfunctional.tv/core-async">LispCast Clojure core.async</a> video course. If you'd like to use core.async but you don't know where to start, this is a good place.</p>
<div class="subscribe-form-wrapper">
  <form class="subscribe-form"
        action="https://lispcast.us4.list-manage.com/subscribe/post?u=a33b5228d1b5bf2e0c68a83f4&amp;id=d0f96276d9"
        method="POST"
        name="mc-embedded-subscribe-form"
        novalidate="true">
      <h3 class="subscribe-form-title">
        
Get a Free core.async Reference Sheet
</h3>
    
<img class="subscribe-form-image"
         src="http://www.lispcast.com/img/core_async_reference_thumb.png">
<div class="subscribe-form-text">
      <p class="subscribe-form-description">
        
Subscribe below to receive a free copy of the core.async reference sheet. If you are interested in core.async, this reference sheet contains lots of the important functions in a handy format. You'll also get a few emails introducing you to core.async.
</p>
      
<input id="mce-EMAIL.email-field"
             type="email"
             value=""
             placeholder="Email"
             name="EMAIL"> <input type="hidden"
             name="group[18565][8]"
             value="1">
<div style="position: absolute; left: -5000px;">
        
<input type="text"
               name="b_a33b5228d1b5bf2e0c68a83f4_d0f96276d9">
</div>
      
<input class="subscribe-button"
             type="submit"
             value="Get it"
             name="subscribe">
<div class="field-text-text2">
        
No spam. Ever.
</div>
    </div>
  </form>
</div>




<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/core-async-browser-motivation">core.async in Browsers</a></li>
<li><a href="http://www.lispcast.com/core-async-code-style">core.async Code Style</a></li>
<li><a href="http://www.lispcast.com/core-async-conveyor-belts-true-history">Conveyor Belts: Nature's core.async Channels</a></li>
<li><a href="http://www.lispcast.com/elm-frp-clojure-core-async">Elm FRP in Clojure core.async</a></li>
</ul>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/reification">
              Reification
            </a>
          </h2>

          <div class="timestamp">
            August 05, 2014
          </div>

          
<p>Summary: <em>Reification means making an abstraction into a concrete value that can be manipulated at runtime. Reification is the core of what makes a language dynamic. Three types of reification in Clojure are discussed.</em></p>
<p>What made Object Oriented programming (in the Smalltalk sense) so powerful? So powerful, in fact, that the GUI, WYSIWYG editing, overlapping windows, MVC, and more, were invented using it, <strong>not to mention an entire programming paradigm</strong>.</p>
<p>What made Lisp so powerful? So powerful that we still see new Lisps popping up and its <strong>legend looms</strong> over every serious programmer's mind.</p>
<p>Now, I don't want to boil it down to <em>one</em> thing. But one thing that was important, that you see in both of these languages, was the idea of <em>reification</em>. In fact, <strong>reification is possibly the essence of what makes a language &quot;dynamic&quot;</strong>.</p>
<p>Reification, as I define it here in this article, means <strong>to make an abstraction available at runtime</strong>. Many languages have a text-based syntax that is read in by a compiler and compiled to machine code. But Smalltalk made each line of code into an object that you could manipulate, either with the input devices or with other code. And it let programmers bootstrap an IDE that was unparalleled at the time.</p>
<p>But Smalltalk's <em>coup de grace</em> reification was the class, which is an object which represents the behavior of another object. Instead of some static switch statement that dispatched the methods, the methods were <strong>stored in a data structure that could be inspected and added to at runtime</strong>. Dynamic dispatch! You see this in multimethods in Clojure.</p>
<p>Clojure's namespaces are reified. Some languages have a linking step in the compiler where modules are brought together to form a binary. But in Clojure, <strong>the namespace is accessible at runtime</strong>. Does your code want to know what Vars are defined? Easy. How about add a new Var. Done. These serve to support interactive programming--a hallmark of dynamic languages.</p>
<p>Lisps have always, from the very beginning, supported <em>homoiconicity</em>, which is a silly way of saying that programs are reified into the language as data. This means you can write functions that write code--also known as <em>macros</em>. Macros serve a very useful bootstrapping function because you can <strong>gradually add to the language instead of having to design it up front</strong>. And sometimes you get a huge win, like <a href="http://clojure.github.io/core.async/">core.async</a>, which adds a totally new semantic.</p>
<p>The next level of reification in Lisps is the higher-order function. Functions are not just things to call, but things to pass as arguments, save in collections, etc. They are real values, just like numbers and strings. There was a time in the history of programming when you could not refer to a function except to call it. Now, we take it for granted. <strong>Being able to reify an abstraction into a thing to pass around is amazing</strong>, and we should all just take a moment to ponder just how awesome it is.</p>
<p>Lisps have traditionally gone to the next level, which is to reify a problem into a <em>data-driven</em> solution. Nowadays, people call this type of programming &quot;DSL&quot;. But it's just a type of reification. Instead of writing code to solve the problem, <strong>let's encode the solution as data</strong>. The problem domain is encoded in the interpreter for that data. Now it's accessible at runtime in a way simple code never could be.</p>
<p>Prismatic's Schema is a great example of this. You define a validator for a piece of data using existing data types: maps, vectors, strings, classes, regexes, etc. Then the library can interpret that data structure and tell you if a piece of data is described by that validator. <strong>If schemas were merely a static construct, this would not be possible.</strong> You would have to wait for the language to &quot;support&quot; it, which is a terrible form of tyranny.</p>
<p>Here's the secret to compounding the power: that data structure can be interpreted in many ways. Take Prismatic's Schema again. You can generate schemas at runtime. You can print them out. You can use them to <a href="https://www.youtube.com/watch?v=4-sPhFtGwZk&amp;feature=youtu.be">build test.check generators</a>. When things are reified and use the same interface as everything else, you can see synergy between libraries. <strong>You use one reification to enhance another.</strong></p>
<p>Data-driven solutions are superior to macro-driven ones or even higher-order function solutions. Data can be stored. It can go over the wire. It can be meaningful in different contexts. A macro is useful at compile time, which happens once. Functions are black boxes and can really only do one thing (apply to arguments). <strong>But data is just data, ready to be interpreted.</strong></p>
<p>Many Clojure libraries are considered &quot;language features&quot; in other languages. <strong>You don't have to mess with the internals of the language.</strong> Dynamic languages can do this, but Clojure (and most Lisps) has it at enough levels that interesting things happen.</p>
<p>Here's another reification: Haskell reifies side effects into values that can be composed. That's cool.</p>
<p>If you're into this whole reification thing, where language features that require major releases in other languages are just libraries; if you think you should learn functional programming; if you are curious about what everyone is talking about, check out the <a href="http://www.purelyfunctional.tv/intro-to-clojure">LispCast Introduction to Clojure</a> video series.</p>
<p>The series is 1.5 hours taking you <strong>from zero Clojure knowledge through data-driven programming</strong>, one of the coolest types of reification. You'll help a robot who always wanted to be a baker learn to make bread :) Help him learn the recipes and convert them from static code to dynamic data.</p>
<div class="article-offer-box">
  
<a class="article-offer-box-link" href="http://www.purelyfunctional.tv/intro-to-clojure">
<div class="article-offer-box-text-wrapper">
      <div class="article-offer-box-text">
        <div class="article-offer-box-text-pitch">
          
Learn Functional Programming using Clojure with screencasts, visual aids, and interactive exercises
</div>
        <div class="offer-box-buy-button">
Learn more
</div>
      </div>
    </div>
    
<img class="article-offer-image" src="http://www.purelyfunctional.tv/img/intro-shot.png"> </a>
</div>





<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/infinite-application">Infinite Application</a></li>
</ul>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/core-async-browser-motivation">
              core.async in Browsers
            </a>
          </h2>

          <div class="timestamp">
            July 29, 2014
          </div>

          
<p>Summary: <em>Javascript's concurrency model forces code to give up control of when a callback will be called. <code>core.async</code> gives you back that control and hence lets you code in a more natural style.</em></p>
<p>Well, there comes a time in every programmer's life when they take a look at the <a href="http://www.thoughtworks.com/radar/#/languages-and-frameworks/core-async">ThoughtWorks Technology Radar</a> and they realize that <code>core.async</code> is in the Trial circle, meaning <strong>you should see if you might want to use it</strong>.</p>
<p>And if you're there, right there in that phase of your programming trajectory, eyeballing <code>core.async</code> for your next (or current) project, Welcome. This post is for you. Here it goes.</p>
<p><strong>Why <code>core.async</code>?</strong> Well, the short answer is that it makes concurrency much, much, much, very much easier. I mean, let's face it: <strong>concurrency is so hard by itself</strong>, it has plenty of muches to spare. Now, I haven't used <code>core.async</code> a lot on the JVM. I wrote some, but it wasn't really the right thing for it. I plan on writing more later, I just haven't had the right project for it.</p>
<p>But I have used it a lot in ClojureScript in browsers. <sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> And it is nice. It lets you do things that you could write yourself, given enough time. But you're more likely to solve the 16-ring Tower of Hanoi before you get all the kinks out. It's much better to <strong>let a machine do the hard work</strong>. That's what the 20th Century was all about: machines instead of muscle. And the 21st Century will be about computers instead of brains. Best get ahead of the curve.</p>
<p>I say you should let the machine do the work, but maybe that's too vague. Let's look at a concrete example. First, <strong>how do you do an ajax request then do something with the value?</strong> Easy:</p>
<pre><code>(ajax &quot;http://example.com/json-api&quot;
      #(js/console.log %))</code></pre>
<p><sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p>We're in Javascript, so we have to pass a callback which will get the result. That was easy. A little harder is <strong>making two API calls and doing something with both results</strong>.</p>
<pre><code>(ajax &quot;http://example.com/random-number&quot;
      (fn [r1]
        (ajax &quot;http://example.com/non-random-number&quot;
              (fn [r2]
                (js/console.log (/ (:n r1) (:n r2)))))))</code></pre>
<p>Alright, that wasn't too bad. <strong>A little indentation never hurt anyone.</strong> But, wait a second! <strong>We don't do the second request until the first request is already done.</strong> I've got a browser the size of a minivan and a 20 Megabit internet connection, and I'm doing one request at a time? That sucks!</p>
<p>We could start them both at the same time. But what order will they come back in? Welcome to the world of concurrency!!!! Things happening (maybe) at the same time, or at least <strong>you don't know what order they will happen in!</strong></p>
<p>Well, let's try something. What if <strong>the first one to finish wrote its result down, then the second one to finish would know that it was second</strong> and it could do the final calculation? What would that look like?</p>
<pre><code>(def r1 (atom nil))
(def r2 (atom nil))

(defn final-calculation []
  (js/console.log (/ @r1 @r2)))

(defn try-final-calculation []
  (when (and @r1 @r2)
    (final-calculation)))

(ajax &quot;http://example.com/random-number&quot;
  #(do
    (reset! r1 %)
    (try-final-calculation)))

(ajax &quot;http://example.com/non-random-number&quot;
  #(do
    (reset! r2 %)
    (try-final-calculation)))</code></pre>
<p>Ok, well, that should work. What happens if you have to do 3 AJAX requests? Not so bad, either. What about 17? Oh, man, that sucks. We could do something like make a super-promise, where <strong>you can promise many values and only call a function at the end</strong> when they're all there. Yes, you can do that. It really wouldn't be hard, even.</p>
<pre><code>(defn super-promise
  &quot;Create a promise for many values. Use `deliver`
  to add values.

  keys: all of these keys must be present before calling f
  f: the function to call. Will be passed a map.&quot;
  [keys f]
  (let [r (atom {})]
    (add-watch r :promise
               (fn [_ _ _ s]
                 (when (every? #(contains? s %) keys)
                   (f s))))
    r))

(defn deliver [promise key value]
  (swap! promise assoc key value))

(def rs (super-promise [:r1 :r2]
                       (fn [{:keys [r1 r2]}]
                         (js/console.log (/ (:n r1) (:n r2))))))

(ajax &quot;http://example.com/random-number&quot;
  #(deliver rs :r1 %))

(ajax &quot;http://example.com/non-random-number&quot;
  #(deliver rs :r2 %))</code></pre>
<p>Fhew! That's done. It works. It scales to many simultaneous AJAX calls. It's generic. Well, generic for <em>this</em> particular pattern. If we have a different pattern, we'd have to <strong>come up with a different solution</strong>.</p>
<p>We're looking through a small porthole into <em>callback hell</em>. The identifying characteristic of callback hell is that you give over control from your code, which was all nice and procedural and easy to follow, you give the control over to whatever demon is going to call that callback. You sell your virtual soul for a bit of asynchrony. But you can't cheat the Devil. When all is said and done, all of your work gets done but <strong>you need some savior angel to help you coordinate all of the pieces back together again</strong>. In this case, it's the super-promise, which works in the first circle of hell, but even Dante can't help you if you go further.<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup></p>
<p>Now that we've got a decent solution <em>to this particular problem</em> established pre-<code>core.async</code>, let's look at what it would be using <code>core.async</code>. We'll assume that our <code>ajax-channel</code> function returns a <code>core.async</code> channel.</p>
<pre><code>(let [r1-channel (ajax-channel &quot;http://example.com/random-number&quot;)
      r2-channel (ajax-channel &quot;http://example.com/non-random-number&quot;)]
  (go
    (js/console.log (/ (:n (&lt;! r1-channel)) (:n (&lt;! r2-channel))))))</code></pre>
<p>Let me just get it out of the way and never mention it again: <em>it's shorter</em>. It's shorter even than the naive solution using two atoms. And it's shorter than the <code>super-promise</code> solution even if you don't include the <code>super-promise</code> code. I'm done talking about the size, because <strong>it's only a little important</strong>.</p>
<p>Now that that's out there, on to the more significant stuff. First and foremost is that <strong>you never lose control</strong>. The code even reads procedurally. Start two ajax requests and remember the channels. Start a <code>go</code> block (which means run the code asynchronously) and log the result of dividing the first result by the second result.</p>
<p>Does it scale? You betcha! Imagine we need to make 192 imaginary AJAX calls before the Devil takes his due. The <em>only</em> way to do that is to <strong>do them all as fast as the browser fairies let you</strong>.</p>
<pre><code>(let [numbers (range 192)
      urls (map #(str &quot;http://example.com/choir?angelid=&quot; %) numbers)
      channels (map ajax-channel urls)]
  (go
    (doseq [c channels]
      (js/console.log &quot;Got: &quot; (&lt;! c)))))</code></pre>
<p>The AJAX requests come back as fast as they can (meaning arbitrary order), and the results are logged in their original (numeric) order. <strong>You could do them in any order you want. That's because you're not giving up control.</strong></p>
<p>How does this work? How can you have asynchrony and not give up control?</p>
<p>I alluded to it before: <strong>you're making the machine do the work</strong>. That <code>go</code> block up there is actually a powerful macro that transforms your procedural code into a mess of callbacks (like in our <code>super-promise</code> example) that you would never want to write yourself. I mean, maybe you want to, but maybe you're nuts. <strong>And you'll get it wrong.</strong></p>
<p>The transformation in the <code>go</code> block is pretty easy, as things go. It's mechanical. It's easy like lifting a car with your hands. Put enough leverage (by using a jack) and you can do it. It converts an easy motion (pushing down on the lever or turning the screw) into a powerful force. The <code>go</code> macro converts your easy code into a bunch of callbacks and coordinates them with a powerful state machine which will <strong>angelically reassemble them without ever losing control</strong>.</p>
<p>It's all good-ol' callbacks and mutable state underground. But above ground, you've got code that's easy to reason about. No Devil's bargain. You've got an angel negotiating for you. That's the key thing! Channels are amazingly easy to reason about because <strong>each channel is so simple</strong>. But that's a story for another day!</p>
<p>I should just mention that, yes, <code>core.async</code> is about procedural programming. Channels are mutable state. <code>core.async</code> is made for the small <strong>part of your code that is procedural and side-effecting</strong>. Every program has got such a part. If you're doing concurrent things (and in Javascript, you always are), <code>core.async</code> might be able to help provide a first-class mechanism for communication and coordination.</p>
<p>That's what you might call the &quot;core&quot; of <code>core.async</code> in ClojureScript. <strong>It's about regaining control of your asynchronous calls and not smearing your logic across your code in little bits contained in callbacks.</strong> You keep your code's semantic integrity and you keep your sanity.</p>
<p>If <strong>staying out of callback hell is to your liking</strong>, you just might like the divine help of a LispCast video course dedicated to teaching <code>core.async</code> in a gentle, graceful way. Presented in a unique visual format and at just the right pace, LispCast <a href="http://www.purelyfunctional.tv/core-async#channel-preview">Clojure core.async</a> will guide you to a deep understanding of the fundamentals of <code>core.async</code> so you can clean up your code, get more concurrency, and get back control.</p>
<div class="subscribe-form-wrapper">
  <form class="subscribe-form"
        action="https://lispcast.us4.list-manage.com/subscribe/post?u=a33b5228d1b5bf2e0c68a83f4&amp;id=d0f96276d9"
        method="POST"
        name="mc-embedded-subscribe-form"
        novalidate="true">
      <h3 class="subscribe-form-title">
        
Get a Free core.async Reference Sheet
</h3>
    
<img class="subscribe-form-image"
         src="http://www.lispcast.com/img/core_async_reference_thumb.png">
<div class="subscribe-form-text">
      <p class="subscribe-form-description">
        
Subscribe below to receive a free copy of the core.async reference sheet. If you are interested in core.async, this reference sheet contains lots of the important functions in a handy format. You'll also get a few emails introducing you to core.async.
</p>
      
<input id="mce-EMAIL.email-field"
             type="email"
             value=""
             placeholder="Email"
             name="EMAIL"> <input type="hidden"
             name="group[18565][8]"
             value="1">
<div style="position: absolute; left: -5000px;">
        
<input type="text"
               name="b_a33b5228d1b5bf2e0c68a83f4_d0f96276d9">
</div>
      
<input class="subscribe-button"
             type="submit"
             value="Get it"
             name="subscribe">
<div class="field-text-text2">
        
No spam. Ever.
</div>
    </div>
  </form>
</div>




<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/core-async-code-style">core.async Code Style</a></li>
<li><a href="http://www.lispcast.com/core-async-conveyor-belts-true-history">Conveyor Belts: Nature's core.async Channels</a></li>
<li><a href="http://www.lispcast.com/elm-frp-clojure-core-async">Elm FRP in Clojure core.async</a></li>
<li><a href="http://www.lispcast.com/is-core-async-against-clojure-philosophy">Is core.async Against the Clojure Philosophy?</a></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Don't say &quot;the browser&quot; because there are many and they are different.<a href="#fnref1">â†©</a></p></li>
<li id="fn2"><p>Let's imagine these functions exist and work as expected.<a href="#fnref2">â†©</a></p></li>
<li id="fn3"><p>And thank Clojure for the <code>atom</code>, which is like a cross or holy water when you find yourself <em>down there</em>.<a href="#fnref3">â†©</a></p></li>
</ol>
</div>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/stop-refactoring-and-start-factoring">
              Stop Refactoring and Start Factoring
            </a>
          </h2>

          <div class="timestamp">
            July 24, 2014
          </div>

          
<p>Summary: <em>Refactoring is focused on the quality of code, while factoring aims to uncover the underlying beauty of the problem domain, as expressed in code. Instead of cleaning up your code, try factoring.</em></p>
<p>You have some code. You notice that it's not too readable. Maybe it's a little messy. There are some obvious code smells: some repeated code and large functions.</p>
<p>You start refactoring. After a while, it's a clean, neat bit of code. It's very understandable and will be cheaper to modify next time.</p>
<p><strong>But is it correct?</strong></p>
<p>I don't mean in the &quot;all-the-tests-pass&quot; kind of way, because refactoring takes care of that. I mean: <strong>does the code do what it should?</strong> Refactoring only says that it does not modify the outward behavior of the code, not make it more correct. And although it's clear what the code <em>does</em> (thanks to all that cleanup), it's not clear that the code <em>does what it should</em>.</p>
<p>I am a big fan of the book <a href="http://www.amazon.com/gp/product/0201485672/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0201485672&amp;linkCode=as2&amp;tag=lisp0b-20&amp;linkId=XFG25IMDVIX7JQY7">Refactoring</a> by Martin Fowler. It's an edifice of analytical thinking and presentation. Go read it now. <strong>It will make you a better thinker and programmer.</strong> However, I have a slight, semantic beef with refactoring. Here's Fowler's definition from the book:</p>
<blockquote>
<p><em>noun:</em> a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior</p>
<p><em>verb:</em> to restructure software by applying a series of refactorings without changing its observable behavior</p>
</blockquote>
<p>That's a great definition of refactoring. My beef is not with the definition. <strong>My beef is with its purpose</strong>, which is to &quot;make it easier to understand and cheaper to modify&quot;. Again, it's a great thing to make your code easier to understand and cheaper to modify. But that's not what I'm after, most of the time.</p>
<p>What I'm after is <em>code that models the problem</em>. This is the <strong>only reliable way to make software that works</strong>. Code that inadequately models the problem is littered with nested conditionals for special cases, is unnecessarily bound in time and context, and is generally obtuse. You might be able to understand what the code is doing, but it's unclear whether it should be doing it.</p>
<p>The only known way to write code that models the problem is to <em>factor</em>. Let's get a definition:</p>
<blockquote>
<p><em>verb:</em> to decompose code to reveal the structure of the problem</p>
</blockquote>
<p><strong>Factoring is inherently about decomposition.</strong> It means splitting functions into smaller functions (along the structural lines of the problem). It means finding those functions which are fundamental to the problem (you can tell they are fundamental because they are used in multiple places). It means revealing symmetries. It means separating concerns. Factoring is about uncovering structural beauty in problem domains.<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Symmetry, proportion, and harmony.</p>
<p>The problem with factoring is that it takes a long time. And you actually <strong>have to understand the domain</strong>. You have to explore the problem a lot longer, perhaps trying different variations in the code, before you can be satisfied that the code models the problem. Time is not something we have in our &quot;Just ship it!&quot; modern world.</p>
<p>The feeling of refactoring is like bringing order to a room: you put things away, you label things clearly, you might even throw out some old junk. But the feeling of factoring is like rebuilding a room for a specific purpose. Refactoring is cleaning up the kitchen. <strong>Factoring is taking the kitchen apart and building a new kitchen better suited to the styles of the individual chef.</strong> It's not practical to rebuild your kitchen all the time, though it is practical to tidy up. But when you do it, it makes all the difference.</p>
<p>That metaphor gets at the other fundamental difference between factoring and refactoring: refactoring does not change the behavior of the code, while factoring might. It might because the code might turn out to be incorrect for the problem. Refactoring can reveal bugs. But if you're going to fix the bug, you've stopped refactoring and gone to something else. In factoring, changing the behavior is just part of the process. <strong>From the factoring perspective, you're not fixing a bug. You're correcting the expression of your problem.</strong></p>
<p>Refactoring by design and definition is focused on the code itself. Factoring is more of a process. It's a journey the programmer takes into the heart of the problem. In its wake, the hills and valleys of the problem are mapped out in the code. <strong>And the programmer ends, like in most journeys, a different person.</strong></p>
<div class="article-cg-box">
  <p class="article-cg-box-text">
    
For more inspiration, history, interviews, and trends of interest to Clojure programmers, get the free Clojure Gazette.
</p>

<p><a href="http://www.clojuregazette.com/"
     class="article-cg-box-button js-clojuregazette">Learn More</a></p>

<p>
    
Clojure pulls in ideas from many different languages and paradigms, and also from the broader world, including music and philosophy. The Clojure Gazette shares that vision and weaves a rich tapestry of ideas from the daily flow of library releases to the deep historical roots of computer science.
</p>
</div>



<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I suggest you choose a good notation.<a href="#fnref1">â†©</a></p></li>
</ol>
</div>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


        <article class="article">
          <h2 class="article-title-wrapper">
            <a class="article-title"
               href="/ring-1-3">
              Ring 1.3
            </a>
          </h2>

          <div class="timestamp">
            July 22, 2014
          </div>

          
<p>Summary: <em>Ring is great because it closely models the HTTP message format using native Clojure data structures. It strictly defines a message format that any software can use and rely on. With Ring 1.3, the specification has gotten even closer to the HTTP spec.</em></p>
<p>A couple of months ago, Ring 1.3 was released without much fanfare. It included a few improvements and updates, but in general, not much had changed.</p>
<p>One change, though, is very significant: the specification is <em>shorter</em>. It's simpler. Three keys were deprecated in the Ring request map (<code>:content-type</code>, <code>:content-length</code>, and <code>:character-encoding</code>). <strong>These keys were unnecessary because their values were in the headers</strong>, which are also in the Ring request. Equivalent utility functions have been added for pulling the data out of the headers.</p>
<p>Why is this important? While many libraries get more complex and overburdened, <strong>it is refreshing to see a library going in the correct direction of <em>shedding complexity</em></strong>. It does not significantly impact application development. Nor does it reduce the already low barrier to entry. Still, I welcome this kind of change.</p>
<p><strong>Ring is the central specification that ties most of the Clojure web ecosystem together.</strong> The spec <em>should</em> be minimal. <strong>And a mark of good software is that it models the problem very closely without unnecessary abstraction.</strong> Ring merely defines a common format (using Clojure data structures) that mirrors the text-based HTTP message format. That's why Ring has worked so well thus far and why it is appreciated in Clojure.</p>
<p>Because I was so happy about the change, I decided to update my <a href="http://www.lispcast.com/ring-spec-hang-on-wall">Ring Spec to Hang on the Wall PDF</a>. The newly deprecated keys are gone. It used to be two pages long. The Ring Request took up an entire page, and the Response took up about half of one. But now, with three keys removed and a little tweaking of the font sizes, <strong>everything fits on one page</strong>.</p>
<center> 
<a
    href="http://www.purelyfunctional.tv/web-dev-in-clojure#subscribe"><img
    src="http://www.purelyfunctional.tv/img/ring_spec_1_3.png"
    style="box-shadow: 2px 2px 5px #888888; max-width: 200px" /></a>
</center>

<p>One page in big, readable fonts, with just the information you need for quick reference. I like it. <strong>I'm printing one out right now to tack on the wall.</strong> You can <a href="http://www.purelyfunctional.tv/web-dev-in-clojure#subscribe">get a free copy</a> for yourself by getting on the PurelyFunctional.tv mailing list <a href="http://www.purelyfunctional.tv/web-dev-in-clojure#subscribe">here</a>.</p>
<div class="subscribe-form-wrapper">
  <form class="subscribe-form"
        action="https://lispcast.us4.list-manage.com/subscribe/post?u=a33b5228d1b5bf2e0c68a83f4&amp;id=d0f96276d9"
        method="POST"
        name="mc-embedded-subscribe-form"
        novalidate="true">
      <h3 class="subscribe-form-title">
        
Get a Free Ring Spec to hang on your wall
</h3>
    
<img class="subscribe-form-image"
         src="http://www.lispcast.com/img/ring_spec_1_3.png">
<div class="subscribe-form-text">
      <p class="subscribe-form-description">
        
Subscribe below to receive a free copy of a Ring Spec to hang on your wall. If you are programming in Ring (covered in the videos), you'll find it very useful as a reference. You'll also hear about exclusive previews and discounts of other video courses.
</p>
      
<input id="mce-EMAIL"
             class="email-field"
             type="email"
             value=""
             placeholder="Email"
             name="EMAIL"> <input type="hidden"
             name="group[18565][4]"
             value="1">
<div style="position: absolute; left: -5000px;">
        
<input type="text"
               name="b_a33b5228d1b5bf2e0c68a83f4_d0f96276d9">
</div>
      
<input class="subscribe-button"
             type="submit"
             value="Get it"
             name="subscribe">
<div class="field-text-text2">
        
No spam. Ever.
</div>
    </div>
  </form>
</div>



<h3 id="you-might-also-like">You might also like</h3>
<ul>
<li><a href="http://www.lispcast.com/cascading-separation-abstraction">Separation, Abstraction, and Cascading in CSS</a></li>
<li><a href="http://www.lispcast.com/clojure-web-security">Clojure Web Security</a></li>
<li><a href="http://www.lispcast.com/hiccup-tips">Hiccup Tips</a></li>
<li><a href="http://www.lispcast.com/json-serialization-api-clojure">JSON Serialization for APIs in Clojure</a></li>
</ul>


          <div class="endmark">
            <a class="endmark-link"
               href="/">
              <img class="endmark-lambda"
                   src="/img/lambda.png" />
            </a>
          </div>

        </article>


      <div class="notes">

      </div>

    </div>

    <footer class="footer-banner">
      <a class="footer-previous"
         href="page15.html">
        <i class="fa fa-chevron-left footer-arrow"></i>
      </a>
      <a class="footer-next"
         href="page13.html">
        <i class="fa fa-chevron-right footer-arrow"></i>
      </a>
    </footer>


    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <script>

      document.write('<script src="https://oberon.herokuapp.com/cookie/get.js?_=' + (new Date()).getTime() + '"><\/script>');

          if(window.oberon && mixpanel) {
            if(document.cookie.indexOf('oberon-id') < 0) {
              var expires = (new Date((new Date().getTime() + 1000*60*60*24*365*10))).toUTCString();
              mixpanel.alias(window.oberon.id);
              document.cookie = "oberon-id=" + window.oberon.id + ";expires=" + expires + ";path=/";
            }
            mixpanel.identify(window.oberon.id);
          }

      mixpanel.register({URL: window.location.pathname,
                         Title: $("title").text()});

      mixpanel.track("Page Visit");

      mixpanel.track_forms('.gazette-form', 'Submit Clojure Gazette');
      mixpanel.track_forms('.subscribe-form', 'Subscribe');

      mixpanel.track_links('a.homepage-offer-box-link',
                           'Click PurelyFunctional.tv',
                           function(e) {
                             return {ToURL: $(e).prop('href')};
                           });

      mixpanel.track_links('a.js-clojuregazette',
                           'Click Clojure Gazette',
                           function(e) {
                             return {ToURL: $(e).prop('href')};
                           });

      $('input[name=EMAIL]').change(function() {
                                                      var i = $(this);
                                                      window.o_email = i.val();
                                                      });

      $('form').submit(function() {
        if(window.o_email)
          mixpanel.people.set({"$email": window.o_email});
});

    </script>

  </body>
</html>
